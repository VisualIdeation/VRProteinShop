/*
BuildBeta: Uses probability results of Ingo Ruczinski's PhD thesis on
protein fold topology, and of Zhu and Braun on sequence matching
specificity between adjacent strands in a sheet, to automatically
produce a higher probability collection of possible initial sheet
conformations, and write them out to separate files.
The variables discussed below can be initialized in the BuildBeta section
of the ProteinShop.cfg file.

If the variable shorten is greater than 0, the predicted strands will
be shortened to account for the limits of matching with any adjacent strands
in order to allow more flexibility in the adjacent coil regions. When
this is done, the energy estimate is increased by the beta strand
prediction certainty times strand_to_coil_penalty. If the variable
interact is non-zero, the program stops after every structure is attempted
and asks in the command line window whether the user wants an early
return in order to examine the structure attempt with interactive graphics.
If interact > 1 ,the program stops multiple times per structure, once
when each beta strand moves, once after every motion of
an alpha helix that is being positioned parallel to the beta sheet,
and once after every correction motion to put the beta sheet back together
if the attempted motion of the alpha helix broke it.
If the variable flatten is non-zero, the beta strands are flattened.
If the variable optimized_angles is zero, the beta strands are flattened
using standard phi and psi angles which make them planar, or close to planar,
depending on the values set below for flatPhi and flatPsi. If it is non-zero
optimized angles depending on the amino acid position, strand length, and
"up" directions of adjacent strands are used. These angles were optimized
using polyalanine, and fake forces to favor hydrogen bonds.
If offlineBuildBeta is equal to 1, the program will proceed directly to create
the conformation files without any display or user input. Otherwise, the
graphics display will be initialized, and the BuildBeta routine can be
called by typing a 'd' with the cursor on the graphics display window.
The variable flatfrac is the fraction
of the way between the nominal beta strand phi and psi angles in the
middle of the distribution on the Ramachandran plot, and the completely
flattened values for no twist in the strand.
The variable spacing is the distance between the beta sheet and any alpha
helices that are automatically placed parallel to it, and also between the
layers of alpha helices, if further layers are needed because more than
one alpha helix separated two beta strands in the sequence.

The current implementation is limited to ten strands or less, which is
the limit of Ingo Ruczinski's data fitting, and makes no attempt to make
two or more sheets; all beta strands are placed in one beta sheet,
unless extending sheets found in a presupplied core.
The values TWO, THRE, FOUR, and FIVE below can be changed in the source to
modify the number of structures that will be attempted.

The program outputs each structure twice, once before the alpha helix
motion attempt, and again if this attempt succeeds, overwriting the
first version. If the alpha helix motion does not succeed, the first
file written remains, with a correct beta sheet, but perhaps with alpha
helices intersecting it. The program makes no attempt to move loops
out of the way of the sheet.

The array position maps the beta strands in the sequence order to the
left to right order in the sheet, and the array positionInverse maps
the strand order in the sheet to the order in the sequence. Possible
sheet topologies are generated by considering all permutations for the 
array position, all possible up or down orientations of each strand,
and the two possible sides of the first strand in the sheet
for hydrogen bonding to the second. Candidate matches evaluated by
the alignment energy terms of Zhu and Braun. 

In case that a .pdb file with a core structure that should be preserved
is input, there may be more than on sheet. The sheets in the core are
discovered by looking for hydrogen bonding. Then there is an initial
loop to distribute the beta strands into the respective sheets, consistent
with the topology of the parts that are already in the core.

In this case, sh[k] says which beta sheet contains strand k,
sheetPosition[k] says what initial position it has in that sheet,
sheetPositionInverse[sheet][i] = k means sheetPosition[k] = i and sh[k] 
= sheet. These initial positions are modified by permutations, so that
position[sh[k]][sheetPosition[k]] describes its sequential position in the
sheet after a permutation. Then  k = positionInverse[sheet][i] gives the
strand index k so that 

position[sh[k]][sheetPosition[k]] = i.

***********************************************************************
Copyright (c) 2004 The Regents of the University of California, through
Lawrence Berkeley National Laboratory, University of California at
Davis, and Lawrence Livermore National Laboratory, subject to any
required approvals from the U.S. Department of Energy.
Adaptations to g++ 4.3.x copyright (c) 2009 Oliver Kreylos

This source code is part of the ProteinShop software.

ProteinShop is copyrighted and your use is under license, subject to
any required approvals from the U.S. Department of Energy.  For details
or questions, you may contact Berkeley Lab's Technology Transfer
Department at TTD@lbl.gov (Re:  ProteinShop; CR-1877)

NOTICE OF U.S. GOVERNMENT RIGHTS.  ProteinShop was developed under
funding from the U.S. Government which consequently retains certain
rights as follows: the U.S. Government has been granted for itself and
others acting on its behalf a paid-up, nonexclusive, irrevocable,
worldwide license in ProteinShop to reproduce, prepare derivative
works, and perform publicly and display publicly.  Beginning five (5)
years after the date permission to assert copyright is obtained from the
U.S. Department of Energy, and subject to any subsequent five (5) year
renewals, the U.S. Government is granted for itself and others acting on
its behalf a paid-up, nonexclusive, irrevocable, worldwide license in
ProteinShop to reproduce, prepare derivative works, distribute copies
to the public, perform publicly and display publicly, and to permit
others to do so.

Written by Nelson Max, January - March 2004
***********************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include <string.h>
#include <stdexcept>
#include <Math/Math.h>
#include <Misc/StandardValueCoders.h>

#include "Globals.h"
#include "Protein.h"

#define PI 3.14159265358979323
#define LARGE 40000000
#define MAXRES 1400
#define MAX_STRANDS 11
#define MAX_SHEETS 3
#define MAX_HELICES 11
#define MAX_CORE_SEGMENTS 4
#define MAX_ALPHA 30
#define MAX_ALPHA_BETWEEN_BETA 10
#define MAX_COIL_BETWEEN_CORE 12
// #define THRESHOLD .01 // minimum allowed probability for 3 strand case
// #define MULTI_SHEET_TOPOLOGIES 10
// the values above are probably reasonable vales; the ones below are to force
// all cases to be generated
#define THRESHOLD .0001 // minimum allowed probability for 3 strand case
#define MULTI_SHEET_TOPOLOGIES 962
#define MULTI_SHEET_ALIGNMENTS 45
#define TWO  2  // number of repeated pair alignments allowed in best FOUR
#define THRE 3   // number of matching alignments saved per strand pair
#define FOUR 9   // number of alignments saved for all strands
// #define THRE 7  // number of matching alignments saved per strand pair
// #define FOUR 18 // number of alignments saved for all strands for attempting zipping
#define FIVE 12 // number of sheet topologies saved, each counted twice
               // for the two possible rotations of first strand, which,
		// together with the matches, determines the orientations
		// of all subsequent strands in the sheet. This is for the
		// 3 strand case only. For 5 or more strands this number
		// is try_topologies, set in ProteinShop.cfg.
		// And for 4 strands,the number is in table CaseNum below.
#define FIND_PER_TOPOLOGY 2 // number of successfully built topologies
                    // required to increment successful topololgy count
// #define MAXTOP 20    // number of topologies of equal Ruczinski score saved
#define MAXTOP 962   // number of topologies of equal Ruczinski score saved
                    // must be at least 2*FIVE
int output_bad_helices = 0; // if 1, all structures for which the beta sheets
                       // converged will be output, even if helices could not be moved
			// can be set in ProteinShop.cfg
int enough_topologies = 6; // number of different topologies with at least 
                    // FIND_PER_TOPOLOGY successes that should be found
                    // can also be set in configuration file
int enough_alignments = 4;  // number of alignments per odd value per topology
                    // successfully constructed before breaking from loop
		     // can also be set in configuration file
int max_crossings = 3;  // maximum number of crossings of chain from one beta sheet
                    // to another. Must be at least one less than the number
		     // of (core) sheets.
                    // can also be set in configuration file
int try_topologies = 11;  // number of topologies to be attempted
                    // can also be set in configuration file
int test_zip = 1;    // set to test whether proposed Zhu and Braun matches
                    // can actually be achieved in findCaseBestFOUR.
		     // If test_zip is 2, and no pre-zipping was successful
		     // for the current topology, and shorten > 0, BuildBetas
		     // will go on to attempt more zipping after shortening,
		     // since shortening is not possible at test_zip time.
int check_stretch = 1; // when 1, zipping will not be attempted if the
                      // distance between the carboxyl carbons is too long
		       // for the coil to stretch.
int multi_sheet_topologies = 8;  // number of multi-sheet-topologies to try
int multi_sheet_alignments = 8;  // number of multi-sheet-alignments to try
                                // can be set in Protein_shop.cfg
int move_helices = 1;  // to move helices parallel to the beta sheet
int place_test_zip = 0;  // Set it to 1 to keep last previous test zip
                    // positions and alignments fixed when doing current
		     // test zip. This may restrict flexibility too much.
		     // But if it is zero, there is too much flexibility.
float zip_threshold = 0.0004;  // threshold for IK residual to accept zipping
                            // can be changed from Proteinshop.cfg
int do_all_topologies = 1; // if 1, all possible topologies will be attempted 
                          // for sheets of less than 5 strands, instead of
			   // only those proposed by Ruczinski. Can be changed
			   // from ProteinShop.cfg.
int do_scwrl3  = 0;  // Set this to 1 to automatically run scwrl3 after
                    // writing output file. Can be changed from ProteinShop.cfg.
int writeStructure = 1;// If 1, secondary structure REMARKS appear in pdb output
                      // file. Can be set from ProteinShop.cfg.
int beyond = 1;      // If beyond = 0, the zipping routines will not try forming
                    // hydrogen bonds with residues outside the beta strands
		     // if the proposed zipping fails due to a proline and an
		     // adjacent zipping is to be tried.
/* Hack: External global variable to access last IK iteration's residual: */
double lastIKResidual = 0.0;    // class Joint disappeared, assume it works
float non_bonded_edge_penalty = 0.;
extern int conf[], is_core[], has_core;
extern char inputfilename[];
extern char pred[MAXRES];
extern int residue_type[MAXRES];
int subtract, offlineBuildBeta = 0, bond_angle_check = 0, read_pred = -1;
int write_helices = 0, read_helices = 0, printhair = 2, stretch_skipped = 0;
int checkBondSites = 1, slowTrans = 0;  // used in ProteinFltk.cpp
int sheet = 0;
char *protein_name, pn[120], sequence_file_name[100];
float spacing = 6.;
float strand_to_coil_penalty = 0.;
float flatfrac = .5;
float flflatPhi = -131.85, flflatPsi = 128.15; // completely flattened values
float flatPhi = -126., flatPsi = 134.; // Average of nominal and flattened values
float raflatPhi = -120., raflatPsi = 140.; // nominal beta strand values
typedef ProteinInteractor::Transformation Transformation;
typedef Transformation::Vector Vector;
/* The following arrays are used in ParsePdbFile and ProteinRenderer
  to greate the blue helix planes.   */
float helixCen[MAX_HELICES][3], helixPlane1[MAX_HELICES][3], helixPlane2[MAX_HELICES][3],
  helixNorm[MAX_HELICES][3], helixEnd1[MAX_HELICES][3], helixEnd2[MAX_HELICES][3];
float bb0[3], bb1[3];
int numHelices, opened_helices = 0, num_core_strands[MAX_SHEETS];

extern void applyTransformation(const ProteinInteractor::Transformation& transformation);
extern void addProtein (MD::Protein* newProtein, int Id);
extern void loadProteins (const char *filename);
// extern void cross( double a[3], double b[3], double c[3]);\
// extern void normalize( double a[3]);

namespace MD {   // MD

extern bool writePdbFile(const Protein& protein,const char* filename,bool writeStructure =true);
int *Zhu, totalResidues, doTerms = 2, shorten = 1, // 2 for printing
  direction[2], start_strand[2], end_strand[2], medium = 0,
  interact = 2, optimized_angles = 0, flatten = 1, found, inserted, remove, piece;
float plane[MAX_STRANDS][3], center[MAX_STRANDS][3],
  bbb0[MAX_STRANDS][3], bbb1[MAX_STRANDS][3];
int sheet, totalStrands, betaCount[MAX_SHEETS + 1], mincore[MAX_SHEETS],
  maxcore[MAX_SHEETS], coreCoilCount[MAX_CORE_SEGMENTS],
  betweenCoreCoil[MAX_CORE_SEGMENTS][MAX_COIL_BETWEEN_CORE];
Point corePoint[MAX_CORE_SEGMENTS][3];
Protein::Residue* coreRes[MAX_SHEETS][3];
double *angles, *saveangles, *originalangles, dt, angle1, angle2;

float Pcount[6][7][4][2][2][6];

int position[MAX_SHEETS][MAX_STRANDS], up[MAX_SHEETS][MAX_STRANDS], coilLength[MAX_STRANDS],
  betaLength[MAX_STRANDS], nCoilPieces[MAX_STRANDS], isLong[MAX_STRANDS],
  coilPiece[MAX_STRANDS][MAX_ALPHA_BETWEEN_BETA + 1], placed[MAX_STRANDS],
  alphaPiece[MAX_STRANDS][MAX_ALPHA_BETWEEN_BETA], betaPiece[MAX_STRANDS],
  positionInverse[MAX_SHEETS][MAX_STRANDS], tempPlaced[MAX_STRANDS],
  oddStart[MAX_STRANDS], twoPower[MAX_STRANDS], bestOddStart[MAX_STRANDS][THRE],
  start[MAX_STRANDS - 1], bestStart[MAX_STRANDS - 1][THRE],
  betaStart[MAX_STRANDS], repeat[MAX_STRANDS - 1], isMedium[MAX_STRANDS],
  tempStart[MAX_STRANDS], choice[MAX_STRANDS - 1], twist[MAXRES],
  bestTotalStart[MAX_SHEETS][MAX_STRANDS][FOUR + 1], 
  bestBegin[MAX_SHEETS][MAX_STRANDS][FOUR + 1],
  bestEnd[MAX_SHEETS][MAX_STRANDS][FOUR + 1], helical,
  alphaBegin[MAX_ALPHA], alphaEnd[MAX_ALPHA], firstCoil[MAX_STRANDS],
  lastCoil[MAX_STRANDS], nAlphaPieces[MAX_STRANDS],
  coreCoil[MAX_STRANDS][MAX_ALPHA_BETWEEN_BETA + 1], coreAlpha[MAX_ALPHA],
  coreBeta[MAX_STRANDS], core_edge[MAX_STRANDS][2], firstCoreBeta,
  lastCoreBeta, bestStartTest[MAX_STRANDS - 1][THRE][4],
  foundA[MAX_STRANDS - 1][4], core_sheet[MAX_STRANDS],
  multi_sheet_topology[MULTI_SHEET_TOPOLOGIES + 1][MAX_SHEETS],
  multi_sheet_alignment[MULTI_SHEET_ALIGNMENTS][MAX_SHEETS],
  goodzip[200][2], coreStructure[MAX_CORE_SEGMENTS],
  saveStructure[1000], nAlphaPiecesFirst = 0, nCoilPiecesFirst = 0,
  firstCoilFirst = 0, lastCoilFirst, coilPieceFirst[MAX_ALPHA_BETWEEN_BETA + 1],
  coreCoilFirst[MAX_ALPHA_BETWEEN_BETA + 1], alphaPieceFirst[MAX_ALPHA_BETWEEN_BETA],
  useHairpin[MAX_STRANDS], tryHairpin[MAX_STRANDS], 
  saved_zips[MAX_STRANDS - 1][2], zip_s[MAX_STRANDS - 1][2][3];
double   zip_phi[MAX_STRANDS - 1][2][3][4], zip_psi[MAX_STRANDS - 1][2][3][4];
long int THRE_power[MAX_STRANDS], SHE_power[MAX_STRANDS];

float bestE[MAX_STRANDS - 1][THRE], bestEtest[MAX_STRANDS - 1][THRE][4],
  bestTotalE[MAX_SHEETS][FOUR + 1];
float optPhi[4][13][12], optPsi[4][13][12];

// The arrays below are for all FIVE high probability chain topologies.

int bestTopologyPosition[MAX_SHEETS][MAX_STRANDS][MAXTOP+1],
  bestTopologyUp[MAX_SHEETS][MAX_STRANDS][MAXTOP+1],
  bestM[MAXTOP+1], knL[10][10][10][10][6];
float bestTopologyProbability[MAX_SHEETS][MAXTOP+1],
  bestTotalScore[MULTI_SHEET_ALIGNMENTS],
  bestTotalProbability[MULTI_SHEET_TOPOLOGIES + 1];

double hairpinAngles[2][4][4][2] =  // [alt][flatfrac][turn residue][phi/psi]
{
{
 {{ 155.6227,    43.3471},
  { 167.3207,   173.5257},
  { -45.4771,  -155.9251},
  {  -2.0407,  -178.9318}},

 {{-152.5464,    62.2277},
  {  76.5955,   136.8643},
  {  20.5962,   149.6288},
  {  70.9252,   137.3773}},

 {{-148.0998,    96.1152},
  {  44.7364,   150.7891},
  {  -2.5135,    89.5355},
  { 147.5568,   122.7790}},

 {{ 136.7235,  -134.8865},
  {  34.7460,     2.6802},
  {  97.5562,    67.0489},
  { 140.8371,   176.0925}}
},
{
 {{  31.0464,    12.3601},
  {  32.6164,   155.3598},
  {  70.1025,    31.8530},
  {-145.5397,  -103.5476}},

 {{  41.4948,    39.2824},
  {   6.9772,   165.0164},
  {  51.6261,     5.7270},
  {-107.1346,   -96.8322}},

 {{  78.6898,    53.0245},
  {  40.0096,    -8.8260},
  { 177.9880,   -66.7731},
  {  12.4975,   -75.2702}},

 {{  55.1997,    37.5417},
  {  20.7497,  -118.9741},
  { -32.0126,     8.0599},
  { -98.0503,   -88.2018}}
}
};

int PpTable[6][10] =
{ {0, 1, 2, 3, 4, 0, 0, 0, 0, 0},
 {0, 1, 2, 3, 4, 5, 0, 0, 0, 0},
 {0, 1, 2, 3, 4, 5, 6, 0, 0, 0},
 {0, 1, 2, 3, 3, 4, 5, 6, 0, 0},
 {0, 1, 2, 3, 3, 3, 4, 5, 6, 0},
 {0, 1, 2, 3, 3, 3, 3, 4, 5, 6} };

int JTable[6][10] =
{ {0, 1, 2, 3, 4, 0, 0, 0, 0, 0},
 {0, 1, 2, 3, 4, 5, 0, 0, 0, 0},
 {0, 1, 1, 2, 2, 3, 3, 0, 0, 0},
 {0, 1, 1, 1, 2, 2, 3, 3, 0, 0},
 {0, 1, 1, 1, 2, 2, 2, 3, 3, 0},
 {0, 1, 1, 1, 2, 2, 2, 3, 3, 3} };

// P2[dir][helical][ln]
float P2[2][2][2] = 
{ { {0.01, 0.27}, {0.01, 0.13} },
 { {0.99, 0.73}, {0.99, 0.87} } };

// P3[config][helical][ln]
float P3[12][2][4] =
{ { {.0043, .0056, .0051, .0491}, {.0043, .0058, .0051, .0416} },
 { {.0043, .0056, .0829, .0803}, {.0043, .0058, .0830, .0681} },
 { {.8970, .4014, .2761, .1621}, {.8970, .6107, .4220, .2517} },
 { {.0043, .2622, .0051, .0285}, {.0043, .0423, .0051, .0242} },
 { {.0043, .0056, .0051, .0190}, {.0043, .0058, .0051, .0161} },
 { {.0364, .0115, .5472, .2822}, {.0364, .0118, .4011, .2394} },
 { {.0043, .0056, .0481, .0315}, {.0043, .0058, .0481, .0267} },
 { {.0043, .0056, .0051, .0142}, {.0043, .0058, .0051, .0121} },
 { {.0043, .0056, .0051, .1144}, {.0043, .0058, .0051, .0121} },
 { {.0043, .0056, .0051, .0348}, {.0043, .0058, .0051, .0295} },
 { {.0043, .0270, .0051, .0315}, {.0043, .0279, .0051, .0267} },
 { {.0279, .2587, .0103, .1525}, {.0279, .2668, .0103, .2517} } };

// Permute3[12][3] is the permutations in figure 9.4 of Ruczinski's thesis

int Permute3[12][3] = {
{0, 1, 2}, {0, 1, 2}, {0, 1, 2}, {0, 1, 2},
{0, 2, 1}, {0, 2, 1}, {0, 2, 1}, {0, 2, 1},
{1, 0, 2}, {1, 0, 2}, {1, 0, 2}, {1, 0, 2} };

// Dir3[12][3] gives the directions, with up = 1, and down = 0,
// in left to right order in the sheet, rather than in order along the strand,
// as in Ruczinski's thesis.

int Dir3[12][3] = {
{0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},
{0, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 1, 1},
{0, 0, 0}, {0, 0, 1}, {1, 0, 0}, {1, 0, 1} };

/* To encode figure 9.9 of Ruczinski's thesis, CaseNum[H][ln] is the number of
  cases in each column, Permute4[H][ln][*][4] is the permutation shown, and
  Dir4 [H][ln][*] gives the up/down directions for the strands. Probability4
  gives the corresponding probabilities.                                     */

int CaseNum[2][8] = { {1, 4, 4, 2, 3, 2, 5, 4}, {1, 2, 3, 2, 3, 3, 3, 2} };

int Permute4[2][8][5][4] = {
{ { {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 2, 3, 0}, {0, 1, 2, 3}, {0, 1, 2, 3}, {1, 2, 3, 0}, {0, 0, 0, 0} },
 { {0, 1, 3, 2}, {1, 0, 2, 3}, {0, 1, 2, 3}, {1, 0, 3, 2}, {0, 0, 0, 0} },
 { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 3, 2, 1}, {0, 3, 2, 1}, {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 3, 2, 0}, {0, 2, 3, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 1, 3, 2}, {1, 0, 2, 3}, {0, 3, 2, 1} },
 { {1, 0, 2, 3}, {1, 3, 2, 0}, {1, 2, 3, 0}, {0, 1, 3, 2}, {0, 0, 0, 0} } },
{ { {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 2, 3}, {1, 2, 3, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 1, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 0, 2, 3}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 2, 3}, {0, 3, 2, 1}, {0, 3, 2, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 2, 3, 1}, {1, 3, 2, 0}, {0, 3, 2, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 3, 2}, {0, 3, 2, 1}, {1, 0, 2, 3}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 2, 3, 1}, {0, 1, 3, 2}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} } } };

int Dir4[2][8][5][4] = {
{ { {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 0, 1, 0}, {0, 1, 0, 1}, {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 0, 0} },
 { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}, {1, 0, 0, 1}, {0, 0, 0, 0} },
 { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 0, 1, 0}, {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 1, 0}, {1, 0, 1, 0}, {0, 0, 1, 0} },
 { {0, 0, 0, 0}, {1, 0, 1, 0}, {0, 0, 0, 0}, {0, 1, 0, 1}, {0, 0, 0, 0} } },
{ { {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} }, 
 { {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 0, 1}, {0, 0, 1, 0}, {1, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} },
 { {0, 1, 0, 1}, {0, 1, 0, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0} } } };

float Probability4[2][8][5] = {
{ {.85, 0., 0., 0., 0.},
 {.27, .21, .21, .6, 0.},
 {.51, .18, .14, .08, 0.},
 {.22, .17, 0., 0., 0.},
 {.36, .18, .09, 0., 0.},
 {.38, .24, 0., 0., 0.},
 {.28, .12, .10, .09, .05},
 {.36, .08, .07, .07, 0.} },
{ {.85, 0., 0., 0., 0.},
 {.44, .28, 0., 0., 0.},
 {.49, .28, .13, 0., 0.},
 {.38, .13, 0., 0., 0.},
 {.46, .15, .08, 0., 0.},
 {.27, .18, .16, 0., 0.},
 {.40, .24, .07, 0., 0.},
 {.62, .05, 0., 0., 0.} } };

// P(F | n, h) = FnH[n-5][h][F], where F is first position, and H is helical
float FnH[6][2][5] = 
{ { {.370, .340, .290, .000, .000}, {.570, .330, .100, .000, .000} },
 { {.380, .240, .380, .000, .000}, {.570, .190, .240, .000, .000} },
 { {.375, .125, .375, .125, .000}, {.375, .125, .375, .125, .000} },
 { {.400, .167, .167, .267, .000}, {.400, .167, .167, .267, .000} },
 { {.250, .125, .250, .125, .250}, {.250, .125, .250, .125, .250} },
 { {.400, .111, .111, .111, .267}, {.400, .111, .111, .111, .267} } };

// float pParPair[2] = {0.51, 0.24};  // from Ingo Ruczinski's thesis
// float pParPair[2] = {0.221, 0.084};

// float pJump[2][2] = {{0.25, 0.54}, {0.18, 0.28}};

//  The following are from my recomputation of the mean for the
//  binomial distribution.

float pParPair[6][2] = { {0.163399, 0.051020}, {0.141791, 0.031646},
  {0.352941, 0.094828}, {0.252874, 0.084967}, {0.121212, 0.138889},
  {0.270833, 0.111111} };

float pJump[6][2]    = { {0.161585, 0.106599}, {0.095238, 0.131098},
  {0.273148, 0.195833}, {0.295833, 0.200647}, {0.102564, 0.261111},
  {0.222222, 0.297619} };

int pairwisePotential1[20][20] =
{-29,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-14,-18,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-10,-15,-48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -4,-24,-29,-43,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 27,-25,-31,-45,-48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -9,-16,-31,-28, -5,-50,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-21,-18,  0,-10,-34,-27,-11,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-34, -1, 18,-18,-28, 16,-30,-53,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 25, -2, -2,-32, 21,-36,  1,-73,-75,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-42,  8,  8, 36,-16,-28, 69,-74, 27,-177, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  6, 28, 76, 30, 99, 65, -2, 70,-78, 31,-78,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  4, 38, 18, 30, 57, 15, -3, 44,  0, 12, 21,-68,  0,  0,  0,  0,  0,  0,  0,  0,
 28,  6, 19, 57, 34, 25, 23, 74, 43, 28,  4,-23,-58,  0,  0,  0,  0,  0,  0,  0,
 49, -4, 48, 25,145, 12,-14, 46,-52,  7, 59,-21, -6,-45,  0,  0,  0,  0,  0,  0,
 54, 35, 41, 35, 44, -4, -6, -9,  7, 39, 73, 19,-31, 20,-17,  0,  0,  0,  0,  0,
 -9, 44, 37, 10, 24, 25, 33,-34,107,-45,-21,-13,-22,-56, 28,-15,  0,  0,  0,  0,
 56, 28, 53, 37,  0, 75,  0,  2, 44, 68, 26, -5,-26,-27,  5, 57, 21,  0,  0,  0,
 40, 59, 43, 37,  5, 31,  3,-20, 53, 92, 34, 24,-31,  0,-56,-11, 58, -3,  0,  0,
-26, 24, 51, 80, 26, 33, 61, 74, 21, 53, 87, -3, 32,-43, -3,-61,-43,-79, 11,  0,
 21, 53, 37, 51, 53, 38, 25,137, 44, 17, 41, 10,-27, 76,-20,-14,-112,-85,86, 58
};

int pairwisePotential2[20][20] =
{-33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,-34,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,-23,-26,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,-13, -8, -3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  8,-13,-16,-20,-28,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 15,  7,-10,-20,-14,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 30,-13, -1, -6, -4, -1,-20,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 10, -5, 10,  4,-20,  7,-17, 31,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 55,-15, -1, -7, -4, 13,-12,-18,-30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -6, 59, 14, 31, 22,-13,-50, -7, -8,-102, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7, 35, 35, 31, 42, 33,  8,-11,-25, 53,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -3,  3,-12,-29,  9,-26,-19, -6,-11,-30,101, 62,  0,  0,  0,  0,  0,  0,  0,  0,
  4, -7,-17,-24, -4,-19,-15, -5,-14,-16, 95, 51, 60,  0,  0,  0,  0,  0,  0,  0,
-10,  7,  0, 13, 10,-29, 30, 90, 37,-40, 52, 73, 53, 91,  0,  0,  0,  0,  0,  0,
 -6,104,  6,-23, -1,-24,-25,-57, 38,  5, 88, 63, 23, 83,  9,  0,  0,  0,  0,  0,
 13, -3, -7, 41,  5,-37,  2, 28,-50, 25, -6, 31, 14,-11, 94,-22,  0,  0,  0,  0,
 24,  2,-11,-13, -8,  6, -9,-33,  9, 50, 59, 80, 43,127, 50, 65, 65,  0,  0,  0,
 21,-23, -7, -4, -5,-20, -9, -4, 20,-43,  1, 48, 34, 35, 24, 24, 46, 30,  0,  0,
 18, 29, -5, -6, -1, -1, 22, 49,-11,-25,241, 41, 66, 79, 64, -1, 57,141,147,  0,
 19,  7,-13,-32,-24,-12, 37, 11,-17,-18,103, 64, 68, 73, 55, -1, 14, 42, 79, 57
};

int pairwisePotential3[20][20] =
{-22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-18,-26,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 12,-34,-27,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-11,-13,-24,-42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 20,-21,-20,-26,-43,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-23,-38,-24,-43,-27,-10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-23,-37,-11,-12, -3, -6, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  4, 47,  1,-29,-13,-14,-64,-93,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
-17,-52,-19, -4,  4,-37,-28, 99,-109, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 -3, 40, -3, -5, 18,-26, -8,  6,  5,-91,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 34, 49, 52, 24, 48, 40, 50, 40,113,-14, 94,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  5,  8, 16, 44, 17, 24, 20, -7, 50, 43,-43,  0,  0,  0,  0,  0,  0,  0,  0,
 37, 37, -1, 39,  7, 31, 37, 31, 28, 32, 15,-30,-57,  0,  0,  0,  0,  0,  0,  0,
 13, 13, 25, 27, 41,126, 11, 28,  4, 18,180,  9,-13, 58,  0,  0,  0,  0,  0,  0,
  0, 27, 21, 25, 31, 37, 49, 42, 52,101,-26,-50, -3, 32,-24,  0,  0,  0,  0,  0,
 23,-44, 17,  0, 25, -7,-14, 46, 49,-22, 59,-31, 28,  7, 39, 36,  0,  0,  0,  0,
 34, 36,  6, 17, 13, 42, 33, 13, 27, 25,  0, 13, -9, 17, 39,-37, 61,  0,  0,  0,
 -5, 46,  5, 19, 54, 43,-42, 50,  3, 11,114, 20, 17, -7, 35,-41, 23, -3,  0,  0,
 14, 35, 43, 19, 20, 38, 19, 16, 66, 64, 29, 13,  8,-24,  9, -6,-24,-49, 23,  0,
 20, 25, 13, 21, 31, 20,-18, 23, 10, 87, 52,  1,  2, -1, 67,-34,-56,-51, 12, 35
};

int KreylosToZhu[23] = 
{-1, 1, 17, 13, 18, 9, 14, 19, 0, 15, 4, 3, 16, 8, -1, 5, 10, 11, 12, 7, 6, -1, 2};

float stretch[13][3][3] =
{ { {0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.} }, 
 { {0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.} }, 
 { {0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.} }, 
 { {0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.} }, 
 { {0., 0., 0.}, {0., 0., 0.}, {0., 0., 0.} }, 
 { {2.5, 6.6, 2.6}, {0., 0., 0.}, {0., 0., 0.} }, 
 { {21.1, 20.7, 5.3},  {20.7, 19.5, 7.9},  {7.0,  5.2,  5.6} },
 { {24.2, 25.2, 15.3}, {23.7, 22.2, 11.1}, {23.7, 23.0, 9.7} }, 
 { {28.3, 27.2, 16.9}, {28.1, 25.7, 15.8}, {27.7, 25.5, 13.7} },
 { {31.5, 32.3, 22.7}, {31.0, 30.4, 19.7}, {31.0, 28.9, 17.8} },
 { {35.6, 35.5, 24.6}, {35.4, 34.1, 23.0}, {35.0, 34.1, 21.2} },
 { {38.7, 39.4, 28.3}, {38.2, 37.6, 27.1}, {38.3, 37.6, 25.6} },
 { {42.8, 42.6, 30.5}, {42.6, 41.1, 29.9}, {42.2, 41.0, 28.3} } };


int comparePosition(const void *v1, const void *v2) {
  int i=*((int*)v1);
  int j=*((int*)v2);
  return(i-j);
  }

double dot(Vector A, Vector B) {
  return (A[0]*B[0] + A[1]*B[1] + A[2]*B[2]);
  }

double binomialDistribution(float p, int i, int n) {
  double v = 1.;
  double op;
  int j, k;

  if(i < 0 || i > n) return 0.0;
  op = 1. - p;

  for(j = 0; j < i; ++j) {
     k = j + 1;
     v = (n - j)*p*v/(float)k;
     }
  for(j = i; j < n; ++j)
     v *= op;
  return v;
  }

Transformation congruentMove( Point P0, Point P1, Point P2,
  Point Q0, Point Q1, Point Q2) {

//  Return the transformation that moves triangle P0_P1_P2 to the
//  congruent triangle Q0_Q1_Q2.

  int i, cmpr = 1;
  Vector S1 = Geometry::normalize(P1 - P0);
  Vector T1 = Geometry::normalize(Q1 - Q0);
  Vector S2 = P2 - P0;
  Vector T2 = Q2 - Q0;
  Vector axis1 = Geometry::normalize(Geometry::cross(S1, T1));
  Transformation goalTrans = Transformation::identity;
  double dot1 = dot(S1, T1);
  double angle1 = Math::acos(dot1);
  Transformation trans1 = Transformation::rotate(Transformation::Rotation::
     rotateAxis(axis1,angle1));
  goalTrans.leftMultiply(trans1);
  Vector tS2 = trans1.transform(S2);
  Vector S3 = Geometry::normalize(tS2 - dot(tS2, T1)*T1);
  Vector T3 = Geometry::normalize( T2 - dot( T2, T1)*T1);
  Vector axis2 = Geometry::normalize(Geometry::cross(S3, T3));
  double dot2 = dot(S3, T3);
  double angle2 = Math::acos(dot2);
  Transformation trans2 = Transformation::rotate(Transformation::Rotation::
     rotateAxis(axis2,angle2));
  double dot3 = dot(axis2, T1);
  if(cmpr)
     printf("alignment dot in congruentMove %f\n", dot3);
  goalTrans.leftMultiply(trans2);
  Point tP0 = goalTrans.transform(P0);
  Transformation trans3 = Transformation::translate(Q0 - tP0);
  goalTrans.leftMultiply(trans3);
  if(cmpr) {
     Point R0 = goalTrans.transform(P0);
     Point R1 = goalTrans.transform(P1);
     Point R2 = goalTrans.transform(P2);
     for (i = 0; i < 3; ++i) {
        printf("%f %f %f\n", P0[i], P1[i], P2[i]);
        printf("%f %f %f\n", Q0[i], Q1[i], Q2[i]);
        printf("%f %f %f\n", R0[i], R1[i], R2[i]);
	 printf("\n");
	 }
     }
  return goalTrans;
  }

void printStructure(const Protein* protein) {
  const Protein::Residue* oldPtr = NULL;
  int thisAlpha, thisBeta, structurePrint = 0;
  bool isBeta = false, isAlpha = false, isCoil = false, firstBeta = false;
  int structureIndex = 0, thisStructure, thisCoilPiece, thisAlphaPiece;
  int totalAlpha = 0, totalBeta = 0, firstResidueIndex, atomcount;
  int i, j, k, ib, s0, s1, s2, arraysize, readsize, residueIndex = 0;
  const Protein::SecondaryStructure* currentSecondaryStructure=0;
  int betaCount, totalResidues;

  betaCount = 0;
  totalResidues = 0;
  thisBeta = -1;
  firstCoreBeta = -1;
  lastCoreBeta = -1;
  atomcount = -1;

  for(Protein::ConstAtomIterator aIt=protein->atomsBegin();aIt!=protein->atomsEnd();++aIt)
    	{
	++atomcount;
  	const Protein::Residue* rPtr=aIt->getResidue();
  	if(rPtr->getSecondaryStructure()!=currentSecondaryStructure)
    	   {
	   thisStructure = structureIndex;
	   ++structureIndex;
     	   switch(rPtr->getSecondaryStructure()->getStructureType()) {

     		case Protein::SecondaryStructure::ALPHA_HELIX:
     		isBeta = false;
		isAlpha = true;
		isCoil = false;
		thisAlpha = thisStructure;
     		break;

     		case Protein::SecondaryStructure::BETA_STRAND:
     		thisBeta = betaCount;
     		++betaCount;
	        printf("\n");
     		isBeta = true;
     		firstBeta = true;
		isAlpha = false;
		isCoil = false;
     		break;

     		case Protein::SecondaryStructure::COIL:
     		isAlpha = false;
     		isBeta = false;
		isCoil = true;
     		}
     	   currentSecondaryStructure=rPtr->getSecondaryStructure();
          }
       if(rPtr != oldPtr) {
	   if(0) printf("%d %x %3s %d\n",
	      residueIndex, rPtr, rPtr->getPdbResidueName(),
	      rPtr->getSecondaryStructure()->getStructureType());
	   if( isBeta) {
	      printf("Beta  %3d %3d %4d %3s %2d %d %d\n", totalResidues, thisBeta, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType(),
		 rPtr->getSecondaryStructure()->getStructureType(),
		 saveStructure[residueIndex] );
	      ++totalBeta;
	      }
	   if(isAlpha) {
	      if(1) printf("Alpha %3d %3d %4d %3s %2d %d %d\n", totalResidues, thisAlpha, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType(),
		 rPtr->getSecondaryStructure()->getStructureType(),
		 saveStructure[residueIndex] );
	      ++totalAlpha;
	      }
	   if(isCoil) 
	      printf("Coil  %3d %3d %4d %3s %2d %d %d\n", totalResidues, -1, thisStructure,
	                       rPtr->getPdbResidueName(),  rPtr->getType(),
			       rPtr->getSecondaryStructure()->getStructureType(),
			       saveStructure[residueIndex] );
	   ++residueIndex;
	   if(1 || oldPtr != NULL) ++totalResidues;
	   oldPtr = rPtr;
	   }
	}
  }

int checkBondAngle(int call_id, int residue, int bad) {
  int i, j, k, r = 0;
  static int print_always[3];
  ProteinState *state;
  state = curProtein();
  if (bad == 0) 
     for(j = 0; j < 3; ++j)
        print_always[j] = 0;
  if ( !state ) return 0;

  state->protein->getBondlAngles(residue, residue+1, angles);
  i = residue;
     for (j = 0; j < 3; ++j) {
        k = 3*i+j;
	 if(fabs(angles[k] - saveangles[k]) > 0.02 || print_always[j]) 
	    printf("Singly checked bond angle in residue %d atom %d changed from %f to %f \n",
	       i, j, saveangles[k]*180./PI, angles[k]*180./PI, call_id);
	 if(fabs(angles[k] - saveangles[k]) > 0.02)  {
	    r = 1;
	    print_always[j] = 1;
	    }
	 else
	    print_always[j] = 0;
	 // saveangles[k] = angles[k];
	 }
  return r;
  }

int checkBondAngles(int call_id) {
  int i, j, k, r = 0;
  ProteinState *state;
  state = curProtein();
  if ( !state ) return 0;
  state->protein->getBondlAngles(0, totalResidues, angles);
  for (i = 0; i < totalResidues; ++i) {
     for (j = 0; j < 3; ++j) {
        k = 3*i+j;
	 if(fabs(angles[k] - saveangles[k]) > 0.1) {
	    printf("Bond angle in residue %d atom %d changed from %f to %f at call %d\n",
	       i, j, saveangles[k]*180./PI, angles[k]*180./PI, call_id);
	    r = 1;
	    }
	 saveangles[k] = angles[k];
	 }
     }
  return r;
  }

bool initBuild(const Protein* protein) {

  const Protein::Residue* oldPtr = NULL;
  int thisAlpha, thisBeta, structurePrint = 0;
  bool isBeta = false, isAlpha = false, firstBeta = false;
  int structureIndex = 0, thisStructure, thisCoilPiece, thisAlphaPiece;
  int totalAlpha = 0, totalBeta = 0, firstResidueIndex, atomcount;
  int i, j, k, ib, s0, s1, s2, arraysize, readsize, oldcore,
     newcore, thisCorePointCount, corecount = 0, numResidues, iptr, sptr;
  long int kk, ll;
  FILE *fp, *fp2, *fpseq;
  char line[134], cseq, *cPtr;
  Protein::Residue *oldResidue;

  // printStructure(protein);
  interact = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/interact",0 );
  test_zip = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/test_zip",0);
  check_stretch = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/check_stretch",0);
  enough_topologies = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/enough_topologies",6);
  output_bad_helices = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/output_bad_helices",0);
  do_all_topologies = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/do_all_topologies",1);
  enough_alignments = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/enough_topologies",4);
  max_crossings = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/max_crossings",3);

  multi_sheet_alignments = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/multi_sheet_alignments",4);
  if (multi_sheet_alignments >  MULTI_SHEET_ALIGNMENTS) {
     printf("for this many (%d) multi_sheet_alignments from ProteinShop.cfg\n");
     printf("increase  MULTI_SHEET_ALIGNMENTS inBuildBeta.cpp source.\n");
     printf("multi_sheet_alignments set to MULTI_SHEET_ALIGNMENTS = %d\n",
        MULTI_SHEET_ALIGNMENTS);
     }

  try_topologies = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/try_topologies",11);
  zip_threshold = configFile->retrieveValue<float,Misc::ValueCoder<float> >("/BuildBeta/zip_threshold", .004);
  spacing = configFile->retrieveValue<float,Misc::ValueCoder<float> >("/BuildBeta/spacing", 6.);
  flatfrac = configFile->retrieveValue<float,Misc::ValueCoder<float> >("/BuildBeta/flatfrac",0.4 );
  strand_to_coil_penalty = configFile->retrieveValue<float,Misc::ValueCoder<float> >("/BuildBeta/strand_to_coil_penalty",0.);
  non_bonded_edge_penalty = configFile->retrieveValue<float,Misc::ValueCoder<float> >("/BuildBeta/non_bonded_edge_penalty",0.);
  move_helices = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/move_helices",1 );
  do_scwrl3 = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/do_scwrl3",0 );
  offlineBuildBeta = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/offlineBuildBeta",0 );
  optimized_angles = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/optimized_angles",0 );
  medium = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/medium",0 );
  flatten = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/flatten",0 );
  shorten = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/shorten",1 );
  writeStructure = configFile->retrieveValue<int,Misc::ValueCoder<int> >("/BuildBeta/writeStructure",1 );
  if (!flatten) flatfrac = 0.;
  opened_helices = 0;

  ++try_topologies;
  if(try_topologies > MAXTOP) {
     printf("try_topologies + 1 > MAXTOP so set to MAXTOP.\n");
     printf("If you really need more, increase MAXTOP in source code.\n");
     try_topologies = MAXTOP;
     }
  printf("strand_to_coil_penalty %f flatfrac %f\n",
     strand_to_coil_penalty, flatfrac);

  flatPhi = flatfrac*flflatPhi + (1. - flatfrac)*raflatPhi;
  flatPsi = flatfrac*flflatPsi + (1. - flatfrac)*raflatPsi;

  fp = fopen("binaryPpJ.dat", "r");
  if(structurePrint) fp2 = fopen("structure.out", "w");
  arraysize = 6*7*4*2*2*6;
  readsize = fread(Pcount, sizeof(float), arraysize, fp);
  if(0) printf("readsize %d arraysize %d\n", readsize, arraysize);
  fclose(fp);
  ProteinState *state = curProtein();
  firstResidueIndex = state->protein->getResidueIndexRange().first;
  printf("firstResidueIndex %d\n", firstResidueIndex);

  fp = fopen("Alanine_Optimize_Angles", "r");
  for (i = 0; i < 4; ++i)
     for (j = 4; j <= 12; ++j)	{
        fgets(line,sizeof(line),fp);
	 sscanf(&line[18], "%d", &k);
	 if(k != i+1) {
	    printf("bad case type in file Alanine_Optimize_Angles %d %d %d\n",
	       i, j, k);
	    printf("%s", line);
	    exit(-1);
	    }
	 for(k = 0; k < 5; ++k)                 // skip lines
	    fgets(line,sizeof(line),fp);
	 for(k = 0; k < j; ++k) {
	    fgets(line,sizeof(line),fp);
	    sscanf(line,"%f %f", &optPhi[i][j][k], &optPsi[i][j][k]);
	    }
	 fgets(line,sizeof(line),fp);           // skip one line
	 }

  for(i = 0; i < 20; ++i)
     for(j = i+1; j < 20; ++j) {
        pairwisePotential1[i][j] = pairwisePotential1[j][i];
        pairwisePotential2[i][j] = pairwisePotential2[j][i];
        pairwisePotential3[i][j] = pairwisePotential3[j][i];
	 }

  /* Start checking for secondary structure boundaries: */

  const Protein::SecondaryStructure* currentSecondaryStructure=0;
  totalStrands = 0;
  totalResidues = 0;
  thisBeta = -1;
  firstCoreBeta = -1;
  lastCoreBeta = -1;
  atomcount = -1;
  oldResidue = (Protein::Residue*) 0;
  oldcore = 0;

  for(Protein::ConstAtomIterator aIt=protein->atomsBegin();aIt!=protein->atomsEnd();++aIt)
    	{ // atom loop
	++atomcount;
  	const Protein::Residue* rPtr=aIt->getResidue();
	if(rPtr != oldResidue) { // new resiue actions
	   oldResidue = (Protein::Residue*) rPtr;
	   newcore = is_core[totalResidues + firstResidueIndex];
	   if (newcore != oldcore) {
	      oldcore = newcore;
	      if(newcore) {
	         ++corecount;
		 if(corecount >= MAX_CORE_SEGMENTS) {
		    printf("Increase MAX_CORE_SEGMENTS in BuildBeta.cpp\n");
		    exit(-1);
		    }
                thisCorePointCount = 0;
		 coreCoilCount[corecount] = 0;
		 }
	      else 
	         if(thisCorePointCount < 3 && flatten) printf(
		    "Dangerous to flatten if only %d residues in core\n",
		    thisCorePointCount);
	      }
	   if(newcore && thisCorePointCount < 3) {
	      corePoint[corecount][thisCorePointCount] = 
	         rPtr->getCarboxyl().getMajorAtom()->getPosition();
	      coreRes[corecount][thisCorePointCount] = (Protein::Residue*) rPtr;
	      }
	   ++thisCorePointCount;
	         
	   if(0) printf("%3d %4d %3s is_core %d\n",
	      totalResidues,  thisStructure,
	      rPtr->getPdbResidueName(), 
	      is_core[totalResidues + firstResidueIndex]);
	   saveStructure[totalResidues] =
	      rPtr->getSecondaryStructure()->getStructureType();
	   } // new resiue actions
  	if(rPtr->getSecondaryStructure()!=currentSecondaryStructure)
    	   {  // new secondary structure actions
	   thisStructure = structureIndex;
	   ++structureIndex;
     	   switch(rPtr->getSecondaryStructure()->getStructureType()) {

     	     case Protein::SecondaryStructure::ALPHA_HELIX:
     		isBeta = false;
		isAlpha = true;
		thisAlpha = thisStructure;
		if(newcore)
		   coreStructure[corecount] = thisStructure;
		alphaBegin[thisAlpha] = totalResidues;
		coreAlpha[thisAlpha] = is_core[totalResidues + firstResidueIndex+1];
		if(thisBeta >= 0) {
		   thisAlphaPiece = nAlphaPieces[thisBeta];
		   ++nAlphaPieces[thisBeta];
		   alphaPiece[thisBeta][thisAlphaPiece] = thisStructure;
		   if(thisAlphaPiece == 0 && 
		      nAlphaPieces[thisBeta] == nCoilPieces[thisBeta])
		      firstCoil[thisBeta] = 1;
		   }
	        else {
		   thisAlphaPiece = nAlphaPiecesFirst;
		   ++nAlphaPiecesFirst;
		   alphaPieceFirst[thisAlphaPiece] = thisStructure;
		   if(thisAlphaPiece == 0 && 
		      nAlphaPiecesFirst == nCoilPiecesFirst)
		      firstCoilFirst = 1;
		   }
     		break;

     	     case Protein::SecondaryStructure::BETA_STRAND:
     		thisBeta = totalStrands;
		coilLength[thisBeta] = 0;
		betaLength[thisBeta] = 0;
		nCoilPieces[thisBeta] = 0;
		nAlphaPieces[thisBeta] = 0;
		firstCoil[thisBeta] = 0;
		if(newcore)
		   coreStructure[corecount] = thisStructure;
		betaPiece[thisBeta] = thisStructure;
		betaStart[thisBeta] = totalResidues;
		coreBeta[thisBeta] = is_core[totalResidues + firstResidueIndex+1];
//		coreBeta[thisBeta] = is_core[totalResidues + firstResidueIndex];
		printf("\nthisBeta %d is_core[%d] = %d\n", thisBeta,
		   firstResidueIndex + totalResidues,
		   is_core[totalResidues + firstResidueIndex]);
		if(coreBeta[thisBeta] && firstCoreBeta < 0) 
		   firstCoreBeta = thisBeta;
		if(coreBeta[thisBeta]) lastCoreBeta = thisBeta;
		if(thisBeta > 0) { // set lastCoil for previous strand
		   ib = thisBeta - 1;
		   if( (firstCoil[ib] == 1 &&
		         nCoilPieces[ib] != nAlphaPieces[ib] + 1) ||
	               (firstCoil[ib] == 0 &&
		         nCoilPieces[ib] != nAlphaPieces[ib]) )
		      lastCoil[ib] = 0;
		   else
		      lastCoil[ib] = 1;
		   }
	        else {
		   if( (firstCoilFirst == 1 &&
		         nCoilPiecesFirst != nAlphaPiecesFirst + 1) ||
	               (firstCoilFirst == 0 &&
		         nCoilPiecesFirst != nAlphaPiecesFirst) )
		      lastCoilFirst = 0;
		   else
		      lastCoilFirst = 1;
		   }
     		++totalStrands;
		if (totalStrands > MAX_STRANDS) {
		  printf("%d is too many beta strands; maximum is %d\n",
		     totalStrands, MAX_STRANDS);
		  exit(-1);
		  }
     		isBeta = true;
     		firstBeta = true;
		isAlpha = false;
     		break;

     	     case Protein::SecondaryStructure::COIL:
     		isAlpha = false;
     		isBeta = false;
		if(thisBeta >= 0) {
		   thisCoilPiece = nCoilPieces[thisBeta];
		   coilPiece[thisBeta][thisCoilPiece] = thisStructure;
		   coreCoil[thisBeta][thisCoilPiece] = is_core[totalResidues + firstResidueIndex+1];
//		   coreCoil[thisBeta][thisCoilPiece] = is_core[totalResidues + firstResidueIndex];
		   ++nCoilPieces[thisBeta];
		   if(!coreCoil[thisBeta][thisCoilPiece]) {
		      betweenCoreCoil[corecount][coreCoilCount[corecount]] = thisStructure;
		      ++coreCoilCount[corecount];
		      if(coreCoilCount[corecount] > MAX_COIL_BETWEEN_CORE) {
		         printf("Increase MAX_COIL_BETWEEN_CORE in BuildBeta.cpp\n");
			 exit(-1);
			 }
		      }
		   }
		else {
		   thisCoilPiece = nCoilPiecesFirst;
		   coilPieceFirst[thisCoilPiece] = thisStructure;
		   coreCoilFirst[thisCoilPiece] = is_core[totalResidues + firstResidueIndex+1];
//		   coreCoilFirst[thisCoilPiece] = is_core[totalResidues + firstResidueIndex];
		   ++nCoilPiecesFirst;
		   if(!coreCoilFirst[thisCoilPiece]) {
		      betweenCoreCoil[corecount][coreCoilCount[corecount]] = thisStructure;
		      ++coreCoilCount[corecount];
		      if(coreCoilCount[corecount] > MAX_COIL_BETWEEN_CORE) {
		         printf("Increase MAX_COIL_BETWEEN_CORE in BuildBeta.cpp\n");
			 exit(-1);
			 }
		      }
		   }
     		break;
     		}
     	   currentSecondaryStructure=rPtr->getSecondaryStructure();
          } // new secondary structure actions
       if(rPtr != oldPtr) { // more new residue actions
	   if( isBeta) {
	      printf("Beta  %3d %3d %4d %3s %d\n", totalResidues, thisBeta, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType() );
	      ++betaLength[thisBeta];
	      ++totalBeta;
	      if(structurePrint) fputc('E',fp2);
	      }
	   else if(firstBeta) {
	      ++coilLength[thisBeta];
	      if(0) printf("thisBeta %d coilLength %d isAlpha %d\n",
	         thisBeta, coilLength[thisBeta], isAlpha);
	      }
	   if(isAlpha) {
	      if(0) printf("Alpha %3d %3d %4d %3s %d\n", totalResidues, thisAlpha, thisStructure,
	         rPtr->getPdbResidueName(),  rPtr->getType() );
	      ++totalAlpha;
	      alphaEnd[thisAlpha] = totalResidues;  // keep updating it
	      if(structurePrint) fputc('H',fp2);
	      }
	   if(!isAlpha && !isBeta && structurePrint)
	      fputc('C',fp2);
	   if(1 || oldPtr != NULL) ++totalResidues;
//	   ++totalResidues;
	   oldPtr = rPtr;
	   } // more new residue actions
	
	} // atom loop

  if(1) {
     printStructure(protein);
     printf("\n");
     }
  if(structurePrint) fclose(fp2);
  printf("totalStrands %d totalResidues %d totalAlpha %d totalBeta %d\n",
     totalStrands, totalResidues, totalAlpha, totalBeta);
  if(totalAlpha/totalResidues >= .2) 
     helical = 1;
  else
     helical = 0;
  printf("helical %d\n", helical);

  for(int i = 0; i < totalStrands - 1; ++i) {
     if (betaStart[i+1] - (betaStart[i] + betaLength[i]) > 10)
        isLong[i] = 1;
     else
        isLong[i] = 0;
     if (betaStart[i+1] - (betaStart[i] + betaLength[i]) >= medium)
        isMedium[i] = 1;
     else
        isMedium[i] = 0;
     printf("i %d betaLength %d coilLength %d betaPiece %d betaStart %d isLong %d coreBeta %d\n",
        i, betaLength[i], coilLength[i], betaPiece[i], betaStart[i], isLong[i], coreBeta[i]);
     for(int j = 0; j < nCoilPieces[i]; ++j) {
        printf("  coreCoil[%d] %d", coilPiece[i][j], coreCoil[i][j]);
	 if(j < nCoilPieces[i] - 1)
	    printf(" alphaPiece %d", alphaPiece[i][j]);
	 }
     printf("\n");
     }
   i =  totalStrands - 1;
   printf("i %d betaLength %d coilLength %d betaPiece %d betaStart %d isLong %d coreBeta %d\n",
        i, betaLength[i], coilLength[i], betaPiece[i], betaStart[i], isLong[i], coreBeta[i]);

  angles = new double[ 3*totalResidues*sizeof(double)];
  if(!angles)
     {
  	  msg.Warn(RUNID,"Not enough memory for Build Beta.");
     exit(1);
     } 
  saveangles = new double[ 3*totalResidues*sizeof(double)];
  if(!saveangles)
     {
  	  msg.Warn(RUNID,"Not enough memory for Build Beta.");
     exit(1);
     }
  originalangles = new double[ 3*totalResidues*sizeof(double)];
  if(!originalangles)
     {
  	  msg.Warn(RUNID,"Not enough memory for Build Beta.");
     exit(1);
     } 
  Zhu = new int[ totalResidues*sizeof(int)];
  if(!Zhu)
     {
  	  msg.Warn(RUNID,"Not enough memory for Build Beta.");
     exit(1);
     } 
  i = 0;
  oldPtr = NULL;
  for(Protein::ConstAtomIterator aIt=protein->atomsBegin();aIt!=protein->atomsEnd();++aIt)
    	{
  	const Protein::Residue* rPtr=aIt->getResidue();
	char sts[2];
	sts[1] = 0;
	if(rPtr != oldPtr) {
	   sts[0] = pred[i];
	   oldPtr = rPtr;
	   Zhu[i] = KreylosToZhu[rPtr->getType()];
	   if(0) printf("Zhu[%3d]  %3s  %d  %1s %d\n", i, rPtr->getPdbResidueName(),
	      rPtr->getSecondaryStructure()->getStructureType(), sts, 
	      is_core[i + firstResidueIndex]); 
	   if(0 && Zhu[i] < 0) {
	      printf("bad residue type in InitBuild; i %d rPtr->getType() %d\n",
	         i, rPtr->getType());
	      }
	   ++i;
	   }
	}
  if(0) printf("residue 12 has apparent type %3s\n",
     state->protein->pickResidue(12)->getPdbResidueName()); 
  j = 1;
  kk = 1;
  for(i = 0; i <= totalStrands; ++i) {
     twoPower[i] = j;
     j *= 2;
     THRE_power[i] = kk;
     kk *= THRE;
     }
  numResidues = totalResidues;
  if(flatten) {
     int n, ib, cq, seg;
     for(i = 0; i <= totalStrands; ++i) 
        if(!coreBeta[i]) {
	    Protein::StructureSelector flatteningStrand = state->protein->pickStructure(betaPiece[i]);
	    state->interactor->selectStructure(flatteningStrand);
           state->interactor->clearCoilRegions();
	    if(0) printf("flattening %d residues in strand %d\n", numResidues, i);
           if(numResidues > 2 && state->interactor->isBetaStrand())
             {
             MD::Scalar* phis=new MD::Scalar[numResidues];
             MD::Scalar* psis=new MD::Scalar[numResidues];
             for(j=0;j<numResidues;++j)
                   {
                   phis[j]=Math::rad(flatPhi);
                   psis[j]=Math::rad(flatPsi);
                   }
             undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
             state->interactor->setDihedralAngles(phis,psis);
             delete[] phis;
             delete[] psis;
             undoBuffer.finishInteraction();
             state->proteinRenderer->updateProtein();
             if(state->energyCalculator!=0)
                     state->energyCalculator->updateProtein();
             }
          }
     state->proteinRenderer->updateStructureFlags();
     if(corecount > 1) {
        Point P0 = corePoint[1][0];
        Point P1 = corePoint[1][1];
        Point P2 = corePoint[1][2];
	 Point Q0 = coreRes[1][0]->getCarboxyl().getMajorAtom()->getPosition();
	 Point Q1 = coreRes[1][1]->getCarboxyl().getMajorAtom()->getPosition();
	 Point Q2 = coreRes[1][2]->getCarboxyl().getMajorAtom()->getPosition();
	 Transformation move1 = congruentMove(P0, P1, P2, Q0, Q1, Q2);

        for(seg = 2; seg <= corecount; ++seg) {
	    P0 = corePoint[seg][0];
	    P1 = corePoint[seg][1];
	    P2 = corePoint[seg][2];
	    Q0 = coreRes[seg][0]->getCarboxyl().getMajorAtom()->getPosition();
	    Q1 = coreRes[seg][1]->getCarboxyl().getMajorAtom()->getPosition();
	    Q2 = coreRes[seg][2]->getCarboxyl().getMajorAtom()->getPosition();
	    Point R0 = move1.transform(P0);
	    Point R1 = move1.transform(P1);
	    Point R2 = move1.transform(P2);
	    Transformation goal = congruentMove(Q0, Q1, Q2, R0, R1, R2);

	    Protein::StructureSelector movingStrand = state->protein->pickStructure(coreStructure[seg]);
	    state->interactor->selectStructure(movingStrand);
           state->interactor->clearCoilRegions();

	    ib = seg - 1;
	    for(n = 0; n < coreCoilCount[ib]; ++n) {
		  cq = betweenCoreCoil[ib][n];
	          state->interactor->toggleCoil(state->protein->pickStructure(cq));
	          if(0) printf("BuildBeta toggled left coil %d\n", cq);
		  }
	    if(seg < corecount)
	       for(n = 0; n < coreCoilCount[seg]; ++n) {
	          cq = betweenCoreCoil[seg][n];
	          state->interactor->toggleCoil(state->protein->pickStructure(cq));
	          if(0) printf("BuildBeta toggled right coil %d\n", cq);
	          }
	    applyTransformation(goal);
	    if(lastIKResidual > zip_threshold) {
	       printf("Unable to flatten non-core strands while preserving core structure.\n");
	       printf("Use smaller flatfrac or turn flatten off.\n");
	       exit(-1);
	       }
	    }
	 }
     }
  if(do_scwrl3) { // prepare sequence file with upper and lower case single letter names
     protein_name = &pn[0];
     strcpy(protein_name, inputfilename);
     sptr = 0;
     for(cPtr=protein_name, iptr = 0;*cPtr!='\0';++cPtr, ++iptr) {
        if(*cPtr=='/') sptr = iptr + 1;
        if(*cPtr=='.') break;
        }
     *cPtr = '\0';  // truncate string from first '.';
     protein_name = &pn[sptr];
     strcpy(sequence_file_name, protein_name);
     strcat(sequence_file_name, ".scwrl3_sequence");
     fpseq = fopen(sequence_file_name, "w");
     printf("numResidues %d firstResidueIndex %d read_pred %d sequence string for scwrl3:\n",
        numResidues, firstResidueIndex, read_pred);
     for(i = 0; i < numResidues - 2*read_pred; ++i) {
	 cseq = Protein::Residue::singleLetterNames[residue_type[i]];
	 if (is_core[i + firstResidueIndex])
	    cseq += 'a' - 'A';
	 fputc(cseq, fpseq);
	 putchar(cseq);
	 }
     fputc('\n', fpseq);
     putchar('\n');
     fclose(fpseq);
     }
  return true;
  }

int findCaseBestFOUR(int sheet) {

/*   Finds the best scoring relative alignments for all the strands in a sheet.
    If test_zip is set, only records those that can actually be zipped.     */

  int i, j, k, l, l0, l1, s, ii, len0, len1, firstResidueIndex, strand1, strandzip,
     mins, maxs, b0, e0, b1, e1, oldb1, olde1, k0, k1, p0, p1, n1, strand, sign,
     add, a, m, tempBegin[MAX_STRANDS], tempEnd[MAX_STRANDS], coilprint = 0,
     kzip, r, odd, succeeded[2], too_many, ret, lp, loops, coilPrint = 0, testzipr = 0,
     sp, movable_zips, mz, save_zip_angles, sz, i1, j1, old_test_zip_toggle = 0,
     otherprint = 0, nprolines, q1, q2, turnings, coil_residues, penalty_print = 0,
     both_sides, goodziprint = 0;
  float e, stretch_distance, cdistance;
  long int casec, tempc, caseCount;

  MD::Scalar* dphi = new MD::Scalar[4];
  MD::Scalar* dpsi = new MD::Scalar[4];

   ProteinState *state = curProtein();
   if ( !state ) {
      printf("state = %x at beginning of findCaseBestFOUR\n", state);
      return -2;
      }
   firstResidueIndex = state->protein->getResidueIndexRange().first;

// set default one good trivial case in case there are no movable strands

   for(strand = 0; strand < betaCount[sheet] - 1; ++strand) {
      bestE[strand][0] = 0;
      for (k = 1; k < THRE; ++k)
         bestE[strand][k] = LARGE;
      }

/*   First find best THRE shifts for each strand pair.
    Strand counts along the sheet from left to right,
    while i and j count along the backbone sequence.    */

   if (maxcore[sheet] < 0) {
       if (has_core) {
          printf("has_core is true but maxcore < 0\n");
          exit(-1);
          }
       loops = 1;
       start_strand[0] = 0;
       end_strand[0] = betaCount[sheet] - 1;
       direction[0] = 1;
       tempPlaced[positionInverse[sheet][0]] = 1;
       }
   else if (mincore[sheet] == 0) {
	if (maxcore[sheet] == betaCount[sheet] - 1) {
	   // no strands to move on this sheet in this distribution
	   if(otherprint) 
	      printf("FindCasesBestFOUR returning 1 because no movable strands\n");
	   return 1;
	   }
       loops = 1;
       start_strand[0] = maxcore[sheet];
       end_strand[0] = betaCount[sheet] - 1;
       direction[0] = 1;
       }
   else if (maxcore[sheet] == betaCount[sheet] - 1) {
       loops = 1;
       start_strand[0] = mincore[sheet];
       end_strand[0] = 0;
       direction[0] = -1;
       }
   else {
       loops = 2;
       start_strand[0] = maxcore[sheet];
       end_strand[0] = betaCount[sheet] - 1;
       direction[0] = 1;
       start_strand[1] = mincore[sheet];
       end_strand[1] = 0;
       direction[1] = -1;
       }

   for (lp = 0; lp < loops; ++lp) {  // side of core in sheet
    for(strand =  start_strand[lp];
      strand != end_strand[lp];
      strand += direction[lp]) {    // strand
     strandzip = strand + direction[lp];
     if (direction[lp] > 0)
        strand1 = strand;
     else
        strand1 = strandzip;

// strandzip is the adjacent strand that moves during the zipping.
// strand1 is the lower in-sheet index of the two strands being zipped, and
// must be used as an index for the arrays of alignments s tested, since
// in a one-strand core, the fixed strand may be zipped to on both sides.

     i = positionInverse[sheet][strand];
     j = positionInverse[sheet][strandzip];
     if(!place_test_zip)
        tempPlaced[i] = 1;
     len0 = betaLength[i];
     len1 = betaLength[j];
     mins = 2 - len0;
     maxs = len1 - 2;
     for (k = 0; k < maxs - mins + 1; ++k) {
        goodzip[k][0] = 1;
        goodzip[k][1] = 1;
	 }
     for (k = 0; k < THRE; ++k)
        bestE[strand1][k] = LARGE;

//  Don't bother to find good alignments if both strands are in the core.

     if(coreBeta[i] && coreBeta[j]) {
        bestE[strand1][0] = 0;
	 if(otherprint) printf("BestFour found two adjacent core strands %d and %d in sheet %d\n",
	    i, j, sheet);
	 break;
	 }

//  s is the index displacement of the first strand from the second, strandzip,
//  that is, s marks the beggining of the first strand in its displaced
//  position, counting from the begining of the second strand
//  both p0 and p1 count from the bottom of the strand as drawn in the sheet
//  k0 marks the begining of the overlap, measured from the begining of the first strand
//  k1 marks the end of the overlap, measured from the begining of the first strand
//  kzip marks the middle of the overlap, measured from the begining of the first strand

     for (odd = 0; odd < 2; ++odd)
       succeeded[odd] = 0;
     if(test_zip) { // test_zip
       if(testzipr)
          printf("\n test zipping strands %d and %d; mins %d maxs %d zip_threshold %g\n",
          i, j, mins, maxs, zip_threshold);

// require structure to be constructable in *either* case of odd,
// without using any strand shortening

       for (odd = 0; odd < 2; ++odd) { // odd
	 if(testzipr) printf("odd %d\n", odd);
	 save_zip_angles = 0;
	 if ((j == i+1 || j == i-1) &&
	    up[sheet][strand] != up[sheet][strandzip] ) {
	    if (i < j)
	       ii = i;
	    else
	       ii = j;
	    if (betaStart[ii] + betaLength[ii] - betaStart[ii + 1] == -4) {
	       save_zip_angles = 1;
	       saved_zips[strand1][odd] = 0;
	       }
	    }
	 if (i < j) {
	    i1 = i;
	    j1 = j;
	    }
	 else {
	    i1 = j;
	    j1 = i;
	    }

// Test zipping by sliding by twos, so huge rotation is not needed at each new configuration

	 for (sp = 0; sp < 2; ++sp)
         for(s = mins + sp; s <= maxs; s += 2) {
	    Protein::StructureSelector movingStrand =
	        state->protein->pickStructure(betaPiece[j]);
	    q1 = betaStart[i1] + betaLength[i1] - 1 + firstResidueIndex;
	    q2 = betaStart[j1] + firstResidueIndex;
	    coil_residues = q2 - q1;

// check_stretch below is incorrect, because the get_position calls for computing
// cd below are for the positions before the move. We must compute the positions after 
// the desired rigid body motion, which requires copying code from the zipping routines.

	    if(0 && check_stretch && j1 == i1 + 1 && nAlphaPieces[i1] == 0 &&coil_residues >= 5) { 
	       nprolines = 0;
	       if (state->protein->pickResidue(q1 + 1)->getAmide().isValid() == 0)
	          ++nprolines;
	       if (state->protein->pickResidue(q2 - 1)->getAmide().isValid() == 0)
	          ++nprolines;
	       if ( up[sheet][strand] != up[sheet][strandzip] )
	          turnings = 1;
	       else
	          turnings = 2;
	       Vector cd =
	        state->protein->pickResidue(q2)->getCarboxyl().getMajorAtom()->getPosition() -
	        state->protein->pickResidue(q1)->getCarboxyl().getMajorAtom()->getPosition();
	       cdistance = sqrt(cd[0]*cd[0] + cd[1]*cd[1] + cd[2]*cd[2]);
	       if (coil_residues <= 12) 
	          stretch_distance = stretch[coil_residues][nprolines][turnings];
	       else if(turnings < 2)
	          stretch_distance = 3.6*coil_residues - 1.2;
	       else
	          stretch_distance = 3.6*coil_residues - 14.2;
	       if (cdistance > stretch_distance + 2.5) {
		  ++stretch_skipped;
                 goodzip[s - mins][odd] = 0;
	          goto next_s;
	          }
	       }
           if(0) printf("s %d odd %d \n", s, odd);
	    if( s > 0 )
	       k0 = 0;
	    else 
	       k0 = -s;
	    if(len1 - s < len0)
	       k1 = len1 - s - 1;
	    else
	       k1 = len0 - 1;
	    kzip = (k0 + k1)/2;
	    if(up[sheet][strand])
	       p0 = betaStart[i] + kzip;
	    else
	       p0 = betaStart[i] + betaLength[i] - 1 - kzip;
	    if(up[sheet][strandzip])
	       p1 = betaStart[j] + kzip + s;
	    else
	       p1 = betaStart[j] + betaLength[j] - 1 - (kzip + s);
	    p0 += firstResidueIndex;
	    p1 += firstResidueIndex;
	    if(0)
	       printf("test zip between strand %d residue %d and strand %d residue %d s %d\n",
	          i, p0, j, p1, s);
	    
	    state->interactor->selectStructure(movingStrand);
           state->interactor->clearCoilRegions();

// Decide which coils should be flexible on this move.
// Superceded by code that only toggles between strands i1 and j1 if old_test_zip_toggle is 0

         if(old_test_zip_toggle) {
           if(coilPrint) {
              printf("placed ");
              for(l = 0; l < totalStrands; ++l)
                 printf("%d ", placed[l] + tempPlaced[l]);
              }
           l = j - 1;
	    found = 0;
	    for (m = 0; m < j; ++m)
	       found += placed[m] + tempPlaced[m];

// only toggle coils if there is an already placed strand before this one.

	    if(coilPrint) printf("testzip placing strand %d coilpieces: left ", j);
	    if(found > 0)
	      while(1) {
	       if( l < 0 || placed[l + 1] || tempPlaced[l + 1])  {
	          if (coilPrint) printf(" break %d placed %d ",
		     l, placed[l + 1]);
	          break;
		  }
              for(m = 0; m < nCoilPieces[l]; ++m)
		 if(!coreCoil[l][m]) {
	          state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][m]));
		  if(coilPrint) printf(" %d", coilPiece[l][m]);
		  }
	       --l;
	       }
	    l = j;
	    if(coilPrint) printf("  right ");
	    found = 0;
	    for (m = j + 1; m < totalStrands; ++m) 
	       found += placed[m] + tempPlaced[m];
	    if(found > 0)
	      while(1) {
	       if(l == totalStrands - 1 || placed[l] || tempPlaced[l]) {
	          if (coilPrint) printf(" break %d placed %d \n",
		     l, placed[l + 1]);
	          break;
		  }
              for(m = 0; m < nCoilPieces[l]; ++m) 
		 if(!coreCoil[l][m]) {
	          state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][m]));
		  if(coilPrint) printf(" %d", coilPiece[l][m]);
		  }
	       ++l;
	       }
	    if(coilPrint) printf("\n");
	    }
         else{

// Decide which coils should be flexible on this move.

           for (l = i1; l < j1; ++l) {
              for(m = 0; m < nCoilPieces[l]; ++m) 
		 if(!coreCoil[l][m]) {
	          state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][m]));
		  if(coilPrint) printf(" %d", coilPiece[l][m]);
		  }
	       }
	    if(coilPrint) printf("\n");
	    }
	    
	    if(up[sheet][strand] == up[sheet][strandzip]) {
	      if((odd + twist[p0]) % 2 == 0) {
		if(offlineBuildBeta == 0 && interact > 2) printf("altZipParallel  ");
	        r = altZipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if (testzipr) {
		   printf("  altZipParallel %d %d residual %g\n", p0, p1, lastIKResidual);
		   fflush(stdout);
		   }
		if(r != 0) goto test_zipped;
		if(beyond || (p0 - 1 - firstResidueIndex >= betaStart[i] &&
		   p1 - 1 - firstResidueIndex >= betaStart[j]) ) {
		   if ((twist[p0 - 1] + twist[p0] + twist[p1 - 1] + twist[p1]) % 2 == 0) {
		      r=zipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		      if (testzipr) printf("  zipParallel %d %d\n", p0-1, p1-1);
		      }
		   else
		      r = 0;
		   if(r != 0) goto test_zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) &&
		      (twist[p0 + 1] + twist[p0] + twist[p1 + 1] + twist[p1]) % 2 == 0) {
		      r=zipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if (testzipr) printf("  zipParallel %d %d\n", p0+1, p1+1);
		      if (r != 0) goto test_zipped;
		      }
		   }
		goto test_quit;
		}
	      else {
		if(offlineBuildBeta == 0 && interact > 2) printf("ZipParallel  ");
	        r = zipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if (testzipr) {
		   printf("  zipParallel %d %d residual %g\n", p0, p1, lastIKResidual);
		   fflush(stdout);
		   }
		if(r != 0) goto test_zipped;
		if(beyond || (p0 - 1 - firstResidueIndex >= betaStart[i] &&
		   p1 - 1 - firstResidueIndex >= betaStart[j]) ) {
		   if ((twist[p0 - 1] + twist[p0] + twist[p1 - 1] + twist[p1]) % 2 == 0) {
		      r=altZipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		      if (testzipr) printf("  altZipParallel %d %d\n", p0-1, p1-1);
		      }
		   else
		      r = 0;
		   if(r != 0) goto test_zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) &&
		      (twist[p0 + 1] + twist[p0] + twist[p1 + 1] + twist[p1]) % 2 == 0) {
		      r=altZipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if (testzipr) printf("  altZipParallel %d %d\n", p0+1, p1+1);
		      if(r != 0) goto test_zipped;
		      }
		   }
		goto test_quit;
		}
	      }
	    else {

// Figure 8A of Zhu and Braun shows anti-parallel strands matched with one flipped.

	      if((odd + twist[p0]) % 2 == 0) {
		if(offlineBuildBeta == 0 && interact > 2) printf("ZipAntiParallel  ");
     if(0 || coilprint) printf("sheet %d lp %d s %d strand %d i %d j %d len0 %d len1 %d\n",
        sheet, lp, s, strand, i, j, len0, len1);
	        r = zipAntiParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[strand], center[strand]);
		if (testzipr) {
		   printf("  ZipAntiParallel %d %d residual %g\n", p0, p1, lastIKResidual);
		   fflush(stdout);
		   }
		if(r != 0) goto test_zipped;
		if(beyond || (p0-1-firstResidueIndex >= betaStart[i] &&
		   p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) ) {
		   if( (twist[p0] + twist[p0-1] + twist[p1] + twist[p1+1]) % 2 == 0) {
		      r = altZipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		      if (testzipr) printf("  ZipAntiParallel %d %d\n", p0-1, p1+1);
		      }
		   else
		      r = 0;
		   if(r != 0) goto test_zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1-1-firstResidueIndex >= betaStart[j]) &&
		      (twist[p0] + twist[p0+1] + twist[p1] + twist[p1-1]) % 2 == 0) {
		      r = altZipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if (testzipr) printf("  ZipAntiParallel %d %d\n", p0+1, p1-1);
		      if(r != 0) goto test_quit;
		      }
		   }
		goto test_quit;
		}
	      else {
		if(offlineBuildBeta == 0 && interact > 2) printf("altZipAntiParallel  ");
	        r = altZipAntiParallel(state->protein->pickResidue(p1),state->protein->pickResidue(p0), plane[strand], center[strand]);
		if (testzipr) {
		   printf("  altZipAntiParallel %d %d residual %g\n", p0, p1, lastIKResidual);
		   fflush(stdout);
		   }
		if(r != 0) goto test_zipped;
		if(beyond || (p0-1-firstResidueIndex >= betaStart[i] &&
		   p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) ) {
		   if( (twist[p0] + twist[p0-1] + twist[p1] + twist[p1+1]) % 2 == 0) {
		      r = zipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[strand], center[strand]);
		      if (testzipr) printf("  altZipAntiParallel %d %d\n", p0-1, p1+1);
		      }
		   else
		      r = 0;
		   if(r != 0) goto test_zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1-1-firstResidueIndex >= betaStart[j]) &&
		      (twist[p0] + twist[p0+1] + twist[p1] + twist[p1-1]) % 2 == 0) {
		      r = zipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[strand], center[strand]);
		      if (testzipr) printf("  altZipAntiParallel %d %d\n", p0+1, p1-1);
		      if(r != 0) goto test_zipped;
		      }
		   }
		goto test_quit;
		}
	      }
	    if(otherprint) printf("center of test-zipping quadrilteral %f %f %f\n",
	       center[strand][0], center[strand][1], center[strand][2]);
test_zipped:
           if (bond_angle_check) checkBondAngles(6);
           if(lastIKResidual <= zip_threshold) {
	       if(save_zip_angles && j1 == i1 + 1 &&
	          betaStart[j1] - (betaStart[i1] + betaLength[i1]) == 4 ) {

/* Save zip angles for successful hairpin. Since the computation of s is non-trivially
  related to the skew of the hairpin, just save the values of s that are found;
  There should be at most 3 of them. This is done in case the successful test zip cannot
  be found when the zip attempt is repeated inside BuildBeta.                           */

		  if(saved_zips[strand1][odd] > 2)
		     printf("Too many saved zip angle sets for strand %d odd %d\n", strand1, odd);
		  else {
		     sz = saved_zips[strand1][odd];
	             e0 = betaStart[strand1] + betaLength[strand1] + firstResidueIndex;
	             state->protein->getDihedralAngles(e0, 4, dphi, dpsi);
		     for (l = 0; l < 4; ++l) {
			zip_phi[strand1][odd][sz][l] = dphi[l];
			zip_psi[strand1][odd][sz][l] = dpsi[l];
			if (printhair > 1) 
			   printf("saving zip strand1 %d odd %d s %d l %d dphi %f dpsi %f\n",
			      strand1, odd, s, l, dphi[l], dpsi[l]);
		        }
		     zip_s[strand1][odd][sz] = s;
		     if (printhair > 0)
		       printf("saved zip angles for strand %d odd %d sz %d s %d\n",
		         strand1, odd, sz, s);
		     ++saved_zips[strand1][odd];
		     }
	          }
	       goto next_s;
	       }
           goodzip[s - mins][odd] = 0;
	    goto next_s;
test_quit:  goodzip[s - mins][odd] = 0;
           if(testzipr)
	       printf("test_zip failed because of too many prolines\n");
next_s: 
	    if(testzipr)
	      printf("test zip between strand %d residue %d and strand %d residue %d s %d goodzip[%d][%d] = %d\n",
	          i, p0, j, p1, s, s-mins, odd, goodzip[s - mins][odd]);
        }
       for (s = mins; s <= maxs; ++s) 
          if (goodzip[s - mins][odd]) ++succeeded[odd];
       } // odd
      if(goodziprint) {
	 printf("goodzips for strand %d i %d strandzip %d j %d mins %d maxs %d\n",
	     strand, i, strandzip, j, mins, maxs);
	 for (odd = 0; odd <= 1; ++odd) {
	     printf("odd = %d:  ", odd);
            for (s = mins; s <= maxs; ++s)
	        printf("%d ", goodzip[s - mins][odd]);
	     printf("\n");
	     }
	 }
      } // test_zip

      for (odd = 0; odd < 2; ++odd) { 
	 // if ((1 || succeeded[odd] == 0) && (i == j+1 || i == j-1) &&
	 if ((0 || succeeded[odd] == 0) && (i == j+1 || i == j-1) &&
	    up[sheet][strand] != up[sheet][strandzip] ) {
	   if (i < j)
	      ii = i;
	   else
	      ii = j;
	   if (betaStart[ii + 1] - (betaStart[ii] + betaLength[ii]) == 4) {

// Add entry for preconstructed hairpin

	     if(printhair > 0)
	        printf("BestFour adding preconstructed hairpin; up[%d] = %d; up[%d] = %d; ii %d odd %d\n",
	        strand, up[sheet][strand], strandzip, up[sheet][strandzip], ii, odd);
            goodzip[0][odd] = 2;
	     succeeded[odd] = 2;
	     }
	   }
	 }

     if(test_zip && succeeded[0] == 0 && succeeded[1] == 0) {
	    if(testzipr)
	       printf("No successful test zip for strand %d in sheet %d\n",
	       strand, sheet);
	    if( !shorten || test_zip < 2) return -1;
	    }

//  Set up to try all zipping alternatives again with shortening, to be done by BuildBeta

     if( shorten && test_zip >= 2) 
        for (s = 0; s < 2; ++s) 
	    if(succeeded[s] == 0)
              for (k = 0; k < maxs - mins + 1; ++k) {
                 if (goodzip[k][s] != 2) goodzip[k][s] = 1;
	          }

//  Now compute best scores for succesfully zipped cases

     for (s = mins; s <= maxs; ++s) { // s loop
      if (goodzip[s - mins][0] || goodzip[s - mins][1]) {

// good test zip found for this s for at least one odd value

        e = 0.;
	 if( s > 0 )
	    k0 = 0;
	 else 
	    k0 = -s;
	 if(len1 - s < len0)
	    k1 = len1 - s - 1;
	 else
	    k1 = len0 - 1;
	 kzip = (k0 + k1)/2;

/*  Increment k1 to be the upper limit for strand iteration loop.
   Modification of p0 and p1 by firstResidueIndex is not needed
   for the purposes of looking up Zhu indez, which is based on
   the position of the residue in the file, not the residue
   number written in the file.                                 */

	 k1 += 1;
	 for (k = k0; k < k1; ++k) {
	    if(up[sheet][strand])
	       p0 = betaStart[i] + k;
	    else
	       p0 = betaStart[i] + betaLength[i] - 1 - k;
	    if(up[sheet][strandzip])
	       p1 = betaStart[j] + k + s;
	    else
	       p1 = betaStart[j] + betaLength[j] - 1 - (k + s);
	    e +=  pairwisePotential1[Zhu[p0]][Zhu[p1]];
	    if(0 && coilprint) printf("%d  ", pairwisePotential1[Zhu[p0]][Zhu[p1]]);

	    for (add = 1; add <= doTerms; ++add) {
	      for(sign = -1; sign <= 1; sign += 2) {
	        a = sign * add;
		n1 = k + a;
		if(n1 >= k0 && n1 < k1) {
	          if(up[sheet][strandzip])
	             p1 = betaStart[j] + n1 + s;
	          else
	             p1 = betaStart[j] + betaLength[j] - 1 - (n1 + s);
		  if (add == 1) 
		     e +=  pairwisePotential2[Zhu[p0]][Zhu[p1]];
		  else
		     e +=  pairwisePotential3[Zhu[p0]][Zhu[p1]];
		     }
	          }
	       }
	     }
	 if(coilprint) 
	    printf("e %f bestE %f %f %f %f\n", e,
	       bestE[strand1][0], bestE[strand1][1],
	       bestE[strand1][2], bestE[strand1][4]);
	 if( goodzip[s - mins][0] == 2 && (i == j+1 || i == j-i) ) {
	    useHairpin[strand1] = 1;
	    if(otherprint) printf("useHairpin[%d] set to 1 in findCasesBestFour\n", strand1);
	    bestE[strand1][0] = 0.;
	    if (up[sheet][strand])
	       bestStart[strand1][0] = len1 - len0;
	    else
	       bestStart[strand1][0] = 0;
	    for (k = 1; k < THRE; ++k)
	       bestE[strand1][k] = LARGE;
	    goto done_s;
	    }
        for(k = 0; k < THRE; ++k) {
           if(e <= bestE[strand1][k]) {
              for(l = THRE - 1; l > k; --l) {
                 bestE[strand1][l] = bestE[strand1][l - 1];
                 bestStart[strand1][l] =  bestStart[strand1][l - 1];
                 }
              bestE[strand1][k] = e;
              bestStart[strand1][k] = s;
	       if (coilprint) 
	          printf("modifying bestTHRE k %d s %d\n", k, s);
              if(offlineBuildBeta == 0 && interact > 3) {
                 printf(" p0 %d  p1 %d type a character:", p0, p1);
                 if(getchar() == 'r') {
                    state->proteinRenderer->updateStructureFlags();
                    return -3;
                    }
                 }
	       break;
              }
           }
        } // good test zip found for this s
       } // s loop
done_s: ;
     if(coilprint) {
       printf("\n");
       for(k = 0; k < THRE; ++k)
	 printf("bestStart[%d][%d] = %d bestE %f\n",
	    strand1, k, bestStart[strand1][k], bestE[strand1][k]);
       }

// The line below is conditional to allow more flexibility in test_zipping: the
// previously placed strands in the same sheet are allowed to move, which may be
// reasonable since their last positions are not necessarily the ones that will
// eventually be used in the final zipping. On the other hand, if they are
// entirely flexible, the test zipping is unrealistic, and worse.

     if(place_test_zip)
        tempPlaced[j] = 1;
     else
        tempPlaced[i] = 0;
     }  //strand
    }   // side of core in sheet 
  if(0) printf("found best THRE\n");
// now pick the best FOUR summed energies over all strands;

  movable_zips = 0;
  for (lp = 0; lp < loops; ++lp)
     movable_zips += abs(end_strand[lp] - start_strand[lp]);
  caseCount = THRE_power[movable_zips];
  for(i = 0; i < FOUR + 1; ++i)
     bestTotalE[sheet][i] = LARGE;
  for (casec = 0; casec < caseCount; ++casec) { //cases among THRE^betaCount
     tempc = casec;
     if(coilprint) printf("casec %d ", casec);
     for(k = 0; k < betaCount[sheet] - 1; ++k) {
        choice[k] = tempc % THRE;
	 tempc /= THRE;
	 if(coilprint) printf("choice %d s %d ", choice[k], bestStart[k][choice[k]]);
	 }
     if(coilprint) printf("\n");
     e = 0;
     mz = 0;
     for (lp = 0; lp < loops; ++lp) {  // side of core in sheet
       for(strand =  start_strand[lp];
         strand != end_strand[lp];
         strand += direction[lp]) {    // strand
        strandzip = strand + direction[lp];
        i = positionInverse[sheet][strand];
        j = positionInverse[sheet][strandzip];
        if (direction[lp] > 0)
           strand1 = strand;
        else
           strand1 = strandzip;
        len0 = betaLength[i];
        len1 = betaLength[j];
	 if(bestE[strand][choice[strand]] == LARGE) goto quitcase;
        i = positionInverse[sheet][strand];
        j = positionInverse[sheet][strandzip];
        len0 = betaLength[i];
        len1 = betaLength[j];
	 e += bestE[strand1][choice[mz]];
	 s = bestStart[strand1][choice[mz]];
	 ++mz;
	 tempStart[strand1] = s;
	 if( s > 0 )
	    k0 = 0;
	 else 
	    k0 = -s;
	 if(len1 - s < len0)
	    k1 = len1 - s - 1;
	 else
	    k1 = len0 - 1;

//  At this point k1 is the actual last residue, not the upper limit of the loop.
//  Compute possible shortening of beta strands in favor of lengthened coils.
	 
	 oldb1 = b1;
	 olde1 = e1;
	 if(up[sheet][strand]) {
	    b0 = betaStart[i] + k0;
	    e0 = betaStart[i] + k1;
	    }
	 else {
	    b0 = betaStart[i] + betaLength[i] - 1 - k1;
	    e0 = betaStart[i] + betaLength[i] - 1 - k0;
	    }
	 if(b0 < betaStart[i])
	    printf("error in shortening b0 computation; i %d b0 %d %d\n",
	       i, b0, betaStart[i]);
	 if(e0 > betaStart[i] + betaLength[i] - 1)
	    printf("error in shortening e0 computation; i %d e0 %d %d\n",
	       i, e0, betaStart[i] + betaLength[i] - 1);
	 if(up[sheet][strandzip]) {
	    b1 = betaStart[j] + k0 + s;
	    e1 = betaStart[j] + k1 + s;
	    }
	 else {
	    b1 = betaStart[j] + betaLength[j] - 1 - k1 - s;
	    e1 = betaStart[j] + betaLength[j] - 1 - k0 - s;
	    }
	 if(b1 < betaStart[j])
	    printf("error in shortening b1 computation; j %d b1 %d %d\n",
	       j, b1, betaStart[j]);
	 if(e1 > betaStart[j] + betaLength[j] - 1)
	    printf("error in shortening e1 computation; j %d e1 %d %d\n",
	       j, e1, betaStart[j] + betaLength[j] - 1);
	 if(coilprint) printf("k0 %d k1 %d s %d b0 %d e0 %d b1 %d e1 %d ",
	    k0, k1, s, b0, e0, b1, e1);
	 for (k = betaStart[i]; k < b0; ++k)
	    e += non_bonded_edge_penalty;
	 for (k = betaStart[i] + betaLength[i] - 1; k > e0; --k)
	    e += non_bonded_edge_penalty;
	 for (k = betaStart[j]; k < b1; ++k)
	    e += non_bonded_edge_penalty;
	 for (k = betaStart[j] + betaLength[j] - 1; k > e1; --k)
	    e += non_bonded_edge_penalty;
	 if(strand != start_strand[lp]) {
	    if(coilprint) printf("oldb1 %d olde1 %d ", oldb1, olde1);
	    if(oldb1 < betaStart[i])
	       printf("error in shortening computation; i %d oldb1 %d %d\n",
	          i, oldb1, betaStart[i]);
	    if(olde1 > betaStart[i] + betaLength[i] - 1)
	       printf("error in shortening computation; i %d olde1 %d %d\n",
	          i, olde1, betaStart[i] + betaLength[i] - 1);
	    if(oldb1 < b0) b0 = oldb1;
	    if(olde1 > e0) e0 = olde1;
	    }

// Don't shorten core strands

	 if (coreBeta[i]) {
	    tempBegin[strand] = betaStart[i];
	    tempEnd[strand] = betaStart[i] + betaLength[i] -1;
	    }
	 else {
	    tempBegin[strand] = b0;
	    tempEnd[strand] = e0;
	    if(coilprint) printf("sheet %d lp %d strand %d i %d tempbegin %d end %d\n",
	       sheet, lp, strand, i, tempBegin[strand], tempEnd[strand]);
	    if (i > 0 && lastCoil[i - 1] == 1)
	       for (k = betaStart[i]; k < b0; ++k) {
	          e += strand_to_coil_penalty*conf[k + firstResidueIndex - subtract];
		  if(penalty_print) printf("added penalty %f for residue %d in strand %d\n",
		     strand_to_coil_penalty*conf[k + firstResidueIndex - subtract], k, i);
		  }
	    if (i < betaCount[sheet] - 1 && firstCoil[i] == 1)
	       for (k = betaStart[i] + betaLength[i] - 1; k > e0; --k) {
	          e += strand_to_coil_penalty*conf[k + firstResidueIndex - subtract];
		  if(penalty_print) printf("added penalty %f for residue %d in strand %d\n",
		     strand_to_coil_penalty*conf[k + firstResidueIndex - subtract], k, i);
		  }
	    }
	 }  // strand

// Add penalty for last strand; b1 and e1 defined by last iteration above.
// On sheets with no core, there should also be a penalty for shortening the
// first strand, but this is currenly not being done. (Now I think it is!)

     strand = end_strand[lp];
     tempBegin[strand] = b1;
     tempEnd[strand] = e1;
     i = positionInverse[sheet][strand];
     if(coilprint) printf("strand %d begin %d end %d\n", strand,
        tempBegin[strand], tempEnd[strand]);
     if (i > 0 && lastCoil[i - 1] == 1)
        for (k = betaStart[i]; k < b1; ++k) 
           e += strand_to_coil_penalty*conf[k + firstResidueIndex - subtract];
     if (i < betaCount[sheet] - 1 && firstCoil[i] == 1)
        for (k = betaStart[i] + betaLength[i] - 1; k > e1; --k) 
           e += strand_to_coil_penalty*conf[k + firstResidueIndex - subtract];
     }  // side of core in sheet

     if(coilprint) printf("tempc %d choice %d %d %d %d  starts %2d %2d %2d  e %g\n", casec,
        choice[0], choice[1], choice[2], choice[3], bestStart[0][choice[0]], 
	 bestStart[1][choice[1]], bestStart[2][choice[2]], e);

// Insert in list of FOUR if energy is better than those so far.
// Actually, create list of FOUR + 1, so that the one causing too many
// repeats can later be removed.

     inserted = 0;
     for(k = 0; k < FOUR + 1; ++k) {
        if(e < bestTotalE[sheet][k]) {
	    if(coilprint){
	      for (strand = 0; strand < betaCount[sheet]; ++strand)
	       printf("strand %d i %d %d tempBegin %d end %d betaStart %d tempStart %d\n",
	       strand, i, positionInverse[sheet][strand], tempBegin[strand],
	       tempEnd[strand], betaStart[positionInverse[sheet][strand]], tempStart[strand]);
	      printf("\n");
	      }
	    inserted = 1;
	    for(l = FOUR; l > k; --l) {
	       bestTotalE[sheet][l] = bestTotalE[sheet][l-1];
	       if(coilprint) printf("bestTotalE[%d] = %f\n", l, bestTotalE[sheet][l]);
              for (strand = 0; strand < betaCount[sheet]; ++strand) {
	          bestTotalStart[sheet][strand][l] = bestTotalStart[sheet][strand][l - 1];
	          bestBegin[sheet][strand][l] = bestBegin[sheet][strand][l-1];
	          bestEnd[sheet][strand][l]   = bestEnd[sheet][strand][l-1];
	          }
	       }
           bestTotalE[sheet][k] = e;
	    if(coilprint) printf("bestTotalE[%d] = %f\n", k, bestTotalE[sheet][k]);
	    if (0 && coilprint) printf("Begin End pairs for k %d casec %d: ",
	       k, casec);
           for (strand = 0; strand < betaCount[sheet]; ++strand) {
              bestTotalStart[sheet][strand][k] = tempStart[strand];
	       bestBegin[sheet][strand][k] = tempBegin[strand];
	       bestEnd[sheet][strand][k]   = tempEnd[strand];
	       if (0 && coilprint) printf("s %d %d %d  ",
	          bestTotalStart[sheet][strand][k],
		  tempBegin[strand], tempEnd[strand]);
	       }
	    if (0 && coilprint) printf("\n");
	    break;
	    }
	 }
     if(inserted) {  //repetitions

// Count repetitions of strand starts that are the same as in the new one
// Then, if they exceed TWO, remove the one of the cases with these repetition
// that has the highest energy.

	 too_many = 0;
	 remove = -1;
        for (strand = 0; strand < betaCount[sheet] - 1; ++strand) {
	    repeat[strand] = 0;
	    for (k = 0; k < FOUR + 1; ++k)
	       if(bestTotalStart[sheet][strand][k] == tempStart[strand]) ++repeat[strand];
	    if(repeat[strand] > TWO) too_many = 1;
	    }
	 if(too_many) {

//  Search for the highest index k, that is, the highest energy, that
//  repeats a start entry agreeing with the test case

	   for (k = 0; k < FOUR + 1; ++k) {
	     for (strand = 0; strand < betaCount[sheet] - 1; ++strand)
	       if (repeat[strand] > TWO &&
	          bestTotalStart[sheet][strand][k] == tempStart[strand])
		     remove = k;
	     }
	   if (remove == -1) {
	     printf("remove = -1 in findCaseBestFOUR\n");
	     exit(-1);
	     }
	   for(l = remove; l < FOUR; ++l) {
	     bestTotalE[sheet][l] = bestTotalE[sheet][l + 1];
	     for (strand = 0; strand < betaCount[sheet] - 1; ++strand) {
	       bestTotalStart[sheet][strand][l] = bestTotalStart[sheet][strand][l + 1];
	       if(coilprint && bestTotalStart[sheet][strand][l] == 10)
	          printf("remove bestTotalStart[%d][%d] = 10\n", strand, l);
	       }
            for (strand = 0; strand < betaCount[sheet]; ++strand) {
	       bestBegin[sheet][strand][l] = bestBegin[sheet][strand][l+1];
	       bestEnd[sheet][strand][l]   = bestEnd[sheet][strand][l+1];
	       }
	     }
	   }
	 }  //repetitions
quitcase: ;	    
     } //cases among THRE^betaCount
  ret = 0;
  for(i = 0; i < FOUR; ++i)
     if(bestTotalE[sheet][i] < LARGE) ++ret;
  if(goodziprint || coilprint)
     for (k = 0; k < ret; ++k) {
	 printf("BestFour ic %d\n", k);
        for(strand = 0; strand < betaCount[sheet]; ++strand) {
	    i = positionInverse[sheet][strand];
           printf("strand %d i %d bestTotalStart %d bestBegin %d bestEnd %d betaStart %d End %d\n",
	       strand, i, bestTotalStart[sheet][strand][k], bestBegin[sheet][strand][k], bestEnd[sheet][strand][k],
	       betaStart[i], betaStart[i] + betaLength[i] - 1);
	    }
	 fflush(stdout);
	 }
  return ret;
  }

void BuildBeta() {   // BuildBeta
  int i, j, l, m, n, L, firstResidueIndex, k, k0, k1, len0, len1, s, p0, p1, jt,
     ia, ib, ibb, ibp, ibq, ic, M, strand, h, ln, twop, od, odd, nextBeta, coilPrint = 0, 
     caseCount, casec, tempc, b0, b1, e0, e1, le1, succeeded = 0, gaveup = 0,
     half, temp, kmin, vmin, J, Js, Pp, Ps, Ns, pu, pl, ju, jl, knl, count, r,
     maxknL, maxcount, numResidues, up0, up1, up2, savep1, shortcount, np, nq,
     below[MAX_STRANDS], firstpos, environment, add, stop, cp, cq, thisAlpha,
     bres, cres, fixp = 0, good, sptr, iptr, coresheetbonds, badcore, jb,
     free_edges, core_parallel[MAX_STRANDS][2], pib, skippedCase1[MAX_STRANDS],
     skippedCase2[MAX_STRANDS], skippedCase3[MAX_STRANDS], num_fac, den_fac,
     skippedCase4[MAX_STRANDS], no_zip = 0, tstrand, crosscount[MAX_STRANDS],
     zipProline, topologies, alignments, foundThisTopology, lengthened,
     longcount, bresp, cresp, printStruct = 0, distpr = 0, pknl = 0, hbpr = 0,
     shpr = 0, one_free, id, icsave, core_sheets, ntopology[MAX_SHEETS],
     tsheet, sheetop, multi_sheet_topology_cases, sfound[MAX_SHEETS], kt, lt, mt,
     mtt, oddprint = 0, extrapr = 0, shortened_sheet, pos0, pos1, sb, sc, sz,
     tempT, new_lengthen = 0, maxalign, printskip = 0, early_skip_print = 0,
     ziprint = 0, sheetpr = 0, allcore, strand1, strandzip, zipcount, hairtry,
     fl, start_topology, end_topology, zipOutPdb = 0, read_anew = 1, centers,
     change_direction, ip, iq, old_average_plane = 0, alphaStop, ii, helixpr = 0,
     make_parallel = 1, printskip0 = 0, twistprint = 0, compatible_distributions = 0,
     distribute_only = 0, printop = 0, set_twist = 1, save_pre_move_helices = 0,
     list_topology_only = 0, crossings, current_sheet, otherprint = 0,
     no_moving_strand;
  float val, den, pFirst, pPpJ, p, sumF, dd, prob, score;
  double v, sum, pj, pjump, pparpair, ppp, maxppp = 0., numerator, denominator,
     lambda, logistic, distribution_score;
  char digits[30], outputfilename[140], *cPtr, ch[2], ECH,
     partialoutputfilename[140], scwrl3_command[300];
  FILE *fp;
  bool par0, par1;
  MD::Point averageCenter;
  MD::Point CC[60];
  MD::Vector averagePlane, strand_direction[MAX_STRANDS];
  MD::Protein::Dipole carboxyl, carboxyl0, carboxyl1, amide0, amide1;
  MD::Protein::Residue* residue;
  MD::Protein::Residue* presidue0;
  MD::Protein::Residue* presidue1;
  MD::Protein::Residue* residue0;
  MD::Protein::Residue* residue1;
  MD::Protein::Residue* residue2;
  MD::Protein::Residue* residue3;
  Point carb1, carb2, carb3, ncarb1, ncarb2, ncarb3;
  MD::Protein::Residue* lresidue1;
  MD::Protein::Residue* lresidue2;
  MD::Protein::Residue* lresidue3;
  MD::Protein::Residue* rpoint;
  Protein *protein;
  bool  validPdbForEnergy = false;
  long int shi, temps, sheetCaseCount;
  int sh[MAX_STRANDS], sheetPosition[MAX_STRANDS], coreSheetSize[MAX_SHEETS],
     sheetPositionInverse[MAX_SHEETS][MAX_STRANDS], displaced_strands = 0,
     lp, loops, sheetalign, sheet_alignment_cases;

  ProteinState *state;
  state = curProtein();
  if ( !state ) return;

  MD::Scalar* save_phis=new MD::Scalar[totalResidues];
  MD::Scalar* save_psis=new MD::Scalar[totalResidues];
  state->protein->getDihedralAngles(0, totalResidues, save_phis, save_psis);
  state->protein->getBondlAngles(0, totalResidues, saveangles);
  state->protein->getBondlAngles(0, totalResidues, originalangles);
  int natoms = totalResidues*22, iat, current_twist, twb, twc;
  MD::Position* save_coords = new MD::Point[natoms];
  MD::Position* pre_move_helices_coords = new MD::Point[natoms];
  iat = 0;
  for(Protein::ConstAtomIterator aIt=state->protein->atomsBegin();aIt!=state->protein->atomsEnd();++aIt)
     save_coords[iat++] = aIt->getPosition();

  MD::Scalar* dphi = new MD::Scalar[4];
  MD::Scalar* dpsi = new MD::Scalar[4];
  Vector DD, old_odir, new_odir, hdir;
  DD[0] = 1.;
  DD[1] = 0.;
  DD[2] = 0.;

  for (i = 0; i < MAX_SHEETS; ++i) {
     skippedCase1[i] = 0;
     skippedCase2[i] = 0;
     skippedCase3[i] = 0;
     skippedCase4[i] = 0;
     }
  gaveup = 0;
  succeeded = 0;
  zipProline = 0;
  for (i = 0; i < MAXRES; ++i)
     twist[i] = 0;
  fprintf(stderr, "BuildBeta is starting\a\n");

  protein_name = &pn[0];
  strcpy(protein_name, inputfilename);
  sptr = 0;
  for(cPtr=protein_name, iptr = 0;*cPtr!='\0';++cPtr, ++iptr) {
     if(*cPtr=='/') sptr = iptr + 1;
     if(*cPtr=='.') break;
     }
  *cPtr = '\0';  // truncate string from first '.';
  protein_name = &pn[sptr];
  printf("protein_name %s\n", protein_name);
  firstResidueIndex = state->protein->getResidueIndexRange().first;
  if(strcmp(state->protein->atomsBegin()->getResidue()->getPdbResidueName(), "ACE") == 0)
     subtract = 1;
  else
     subtract = 0;
  printf("subtract = %d\n", subtract);
/*
  printf ("Residue list with access modified by firstResidueIndex and subtract\n");
  for (j = 0; j < totalResidues; ++j) {
     rpoint = state->protein->pickResidue(j + firstResidueIndex);
     if (j - subtract >= 0)
        ECH = pred[j - subtract];
     else
        ECH = ' ';
     std::cout << j << "  " << ECH << "  " 
      << (state->protein->pickResidue(j + firstResidueIndex))->getSecondaryStructure()->getStructureType() << "  " 
      << (state->protein->pickResidue(j + firstResidueIndex))->getPdbResidueName() << "\n";
     }
*/
  for(strand = 0; strand < totalStrands; ++strand)
	if(coreBeta[strand])
          placed[strand] = 1;
	else
          placed[strand] = 0;

//  Compute twist for all strands.

     for(ib = 0; ib < totalStrands; ++ib) {  // ib
	 if(twistprint) printf("twist for core strand %d is ", ib);
	 bres = betaStart[ib];
	 bresp = bres + firstResidueIndex;
	 residue0 = state->protein->pickResidue(bresp);
	 carboxyl0 = residue0->getCarboxyl();
	 amide0 = residue0->getAmide();
	 current_twist = 0;
	 for (m = 0; m < 3; ++m)
          old_odir[m] = 
	    carboxyl0.getMinorAtom()->getPosition()[m] -
	    carboxyl0.getMajorAtom()->getPosition()[m];
	 if(residue0->getType() != MD::Protein::Residue::PRO) {
	    for (m = 0; m < 3; ++m)
            hdir[m] = 
	      amide0.getMinorAtom()->getPosition()[m] -
	      amide0.getMajorAtom()->getPosition()[m];
	    dt = dot(old_odir, hdir);
	    if (set_twist && dt < 0) current_twist = 1;
	    }
	 twist[bresp] = current_twist;
	 if(twistprint) printf("%d", current_twist);

        for(bres = betaStart[ib] + 1; bres < betaStart[ib] + betaLength[ib]; ++bres) {
	    bresp = bres + firstResidueIndex;
	    residue0 = state->protein->pickResidue(bresp);
	    carboxyl0 = residue0->getCarboxyl();
	    amide0 = residue0->getAmide();
	    for (m = 0; m < 3; ++m)
             new_odir[m] = 
	       carboxyl0.getMinorAtom()->getPosition()[m] -
	       carboxyl0.getMajorAtom()->getPosition()[m];
	    if(residue0->getType() != MD::Protein::Residue::PRO) {
	       for (m = 0; m < 3; ++m)
               hdir[m] = 
	         amide0.getMinorAtom()->getPosition()[m] -
	         amide0.getMajorAtom()->getPosition()[m];
	       dt = dot(new_odir, hdir);
	       if (set_twist && dt < 0) current_twist = 1 - current_twist;
	       }
	    else {
	       dt = dot (old_odir, new_odir);
	       if(twistprint > 1) printf(" %f ", dt);
	       if (set_twist && dt > 0) current_twist = 1 - current_twist;
	       }
	    twist[bresp] = current_twist;
	    for (m = 0; m < 3; ++m)
            old_odir[m] = new_odir[m];
	    if(twistprint) printf("%d", current_twist);
	    }
	 if(twistprint) printf("\n");
	}  // ib

  if(has_core) {   //core
     badcore = 0;

//  find core beta sheet hydrogen bonds

     coresheetbonds = 0;
     for(ib = 0; ib < totalStrands; ++ib) {
	 core_sheet[ib] = -1;
        for(j = 0; j < 2; ++j)
	    core_edge[ib][j] = -1;
	 }

     for(ib = 0; ib < totalStrands; ++ib) {  // ib
      if(coreBeta[ib]) {  // coreBeta[ib]
        for(bres = betaStart[ib]; bres < betaStart[ib] + betaLength[ib]; ++bres) { // bres
	   bresp = bres + firstResidueIndex;
	   residue0 = state->protein->pickResidue(bresp);
	   carboxyl0 = residue0->getCarboxyl();
	   amide0 = residue0->getAmide();
	   if (amide0.isValid() && carboxyl0.isValid()) {  // residue 0 valid
	    if(hbpr) printf(
              "bresp %d amide %8.3f%8.3f%8.3f  carboxyl %8.3f%8.3f%8.3f\n",
                  bresp,
                  amide0.getMinorAtom()->getPosition()[0],
                  amide0.getMinorAtom()->getPosition()[1],
                  amide0.getMinorAtom()->getPosition()[2],
                  carboxyl0.getMinorAtom()->getPosition()[0],
                  carboxyl0.getMinorAtom()->getPosition()[1],
                  carboxyl0.getMinorAtom()->getPosition()[2]);

	    for(ic = ib+1; ic < totalStrands; ++ic)
	     if(coreBeta[ic]) {
	       if(hbpr)
	       printf("Searching bresp %d bonds between strands %d and %d\n",
	          bresp, ib, ic);
	       for(cres = betaStart[ic]; cres < betaStart[ic] + betaLength[ic]; ++cres) {
		  cresp = cres + firstResidueIndex;
	          residue1 = state->protein->pickResidue(cresp);
	          carboxyl1 = residue1->getCarboxyl();
	          amide1 = residue1->getAmide();
		  if( (amide0.isValid()&&carboxyl1.isValid()&&
		       formHydrogenBond( amide0, carboxyl1 ) ) ||
		      (amide1.isValid()&&carboxyl0.isValid()&&
		       formHydrogenBond( amide1, carboxyl0 ) ) ) {
		     if(1) printf(
		        "bresp %d  cresp %d ib %d ic %d core_edges %d %d\n",
		        bresp, cresp, ib, ic, core_edge[ib][(bresp + twist[bresp]) % 2],
		        core_edge[ic][(cresp + twist[cresp]) % 2]);
		     ++coresheetbonds;
		     if(amide0.isValid()&&carboxyl1.isValid()&&
		        formHydrogenBond( amide0, carboxyl1 ) ) {
			printf("Found Hydrogen Bond A ib %d %d ic %d %d\n  NH %f %f %f \n  CO %f %f %F\n",
			   ib, coreBeta[ib], ic, coreBeta[ic],
			   amide0.getMinorAtom()->getPosition()[0], 
			   amide0.getMinorAtom()->getPosition()[1], 
			   amide0.getMinorAtom()->getPosition()[2], 
			   carboxyl1.getMinorAtom()->getPosition()[0], 
			   carboxyl1.getMinorAtom()->getPosition()[1], 
			   carboxyl1.getMinorAtom()->getPosition()[2]); 
			if(bres > 0)
			   twb = twist[bresp-1];
			else
			   twb = 0;
			twc = twist[cresp];
			}
		     if(amide1.isValid()&&carboxyl0.isValid()&&
		        formHydrogenBond( amide1, carboxyl0 ) ) {
			printf("Found Hydrogen Bond B ib %d %d ic %d %d\n  NH %f %f %f \n  CO %f %f %F\n",
			   ib, coreBeta[ib], ic, coreBeta[ic],
			   amide1.getMinorAtom()->getPosition()[0], 
			   amide1.getMinorAtom()->getPosition()[1], 
			   amide1.getMinorAtom()->getPosition()[2], 
			   carboxyl0.getMinorAtom()->getPosition()[0], 
			   carboxyl0.getMinorAtom()->getPosition()[1], 
			   carboxyl0.getMinorAtom()->getPosition()[2]); 
			if (cres > 0)
			   twc = twist[cresp-1];
			else
			   twc = 0;
			twb = twist[bresp];
			}
		     if(core_edge[ib][(bresp + twb) % 2] < 0 &&
		        core_edge[ic][(cresp + twc) % 2] < 0) {
		        core_edge[ib][(bresp + twb) % 2] = ic;
			printf("core_edge[%d][%d] set to %d twist %d\n",
			   ib, (bresp + twb) % 2, ic, twb);
		        core_edge[ic][(cresp + twc) % 2] = ib;
		        printf("core_edge[%d][%d] set to %d twc twist %d\n",
		           ic, (cresp + twc) % 2, ib, twc);
			}
		     else if(core_edge[ib][(bresp + twb) % 2] == ic &&
		        core_edge[ic][(cresp + twc) % 2] == ib) {
			printf("another hydrogen bond found between strands %d and %d\n",
			   ib, ic);
			}
		     else if(core_edge[ib][(bresp + twb) % 2] >= 0 &&
		        core_edge[ib][(bresp + twb) % 2] != ic) {
			ia = core_edge[ib][(bresp + twb) % 2];
			if (betaLength[ic] > betaLength[ia]) {
			   printf("replacing match of strand ib = %d to %d  with %d\n",
			      ib, ia, ic);
			   core_edge[ib][(bresp + twb) % 2] = ic;
		           core_edge[ic][(cresp + twc) % 2] = ib;
			   core_edge[ia][0] = -2; 
			   core_edge[ia][1] = -2; 
			   ++displaced_strands;
			   }
			else {
			   printf("making strand ic = %d have no free edges\n", ic);
			   printf("core_edge[%d][0] was %d\n", ic, core_edge[ic][0]);
			   printf("core_edge[%d][1] was %d\n", ic, core_edge[ic][1]);
			   core_edge[ic][0] = -2; 
			   core_edge[ic][1] = -2; 
			   ++displaced_strands;
			   }
			}
		     else if (core_edge[ic][(cresp + twc) % 2] >= 0 &&
		        core_edge[ic][(cresp + twc) % 2] != ib) {
			ia = core_edge[ic][(cresp + twc) % 2];
			if (betaLength[ib] > betaLength[ia]) {
			   printf("replacing match of strand ic = %d to %d  with %d\n",
			      ic, ia, ib);
			   core_edge[ib][(bresp + twb) % 2] = ic;
		           core_edge[ic][(cresp + twc) % 2] = ib;
			   core_edge[ia][0] = -2; 
			   core_edge[ia][1] = -2; 
			   ++displaced_strands;
			   }
			else {
			   printf("making strand ib = %d have no free edges\n", ib);
			   printf("core_edge[%d][0] was %d\n", ib, core_edge[ib][0]);
			   printf("core_edge[%d][1] was %d\n", ib, core_edge[ib][1]);
			   core_edge[ib][0] = -2; 
			   core_edge[ib][1] = -2; 
			   ++displaced_strands;
			   }
		        } 
		     else {
		        printf ("strange case while processing hydrogen bond ib %d ic %d\n",
			   ib, ic);
			printf("core_edge[%d][0] = %d\n", ib, core_edge[ib][0]);
			printf("core_edge[%d][1] = %d\n", ib, core_edge[ib][1]);
			printf("core_edge[%d][0] = %d\n", ic, core_edge[ic][0]);
			printf("core_edge[%d][1] = %d\n", ic, core_edge[ic][1]);
			badcore = 1;
			}
		     }
	          }
	       }
	    }  // residue 0 valid
	  } // bres
	  bres = betaStart[ib];
	  cres = betaStart[ib] + betaLength[ib];
	  residue0 = state->protein->pickResidue( bres + firstResidueIndex );
	  residue1 = state->protein->pickResidue( cres + firstResidueIndex );
	  strand_direction[ib] =
	     residue1->getCarboxyl().getMajorAtom()->getPosition() -
	     residue0->getCarboxyl().getMajorAtom()->getPosition();
	 }  // coreBeta[ib]
	}  // ib
     if(otherprint) printf("coresheetbonds %d\n", coresheetbonds);
     if(otherprint) printf("displaced_strands %d\n", displaced_strands);
     free_edges = 0;
     core_sheets = 0;
     for(ib = 0; ib < totalStrands; ++ib) {
      if(coreBeta[ib]) {
       if(core_edge[ib][0] == -2)
	 core_sheet[ib] = MAX_SHEETS;
       else {
	 one_free = 0;
        for (k = 0; k < 2; ++k) {
           if (core_edge[ib][k] < 0) {
	          if(core_edge[ib][k] == -1) {
	          ++free_edges;
	          ++one_free;
	          }
	       }
	    else {
	       ic = core_edge[ib][k];
	       dd = dot(strand_direction[ib], strand_direction[ic]);
	       if (fabs(dd) < 0.5) {
	          printf("Bad alignment of strands %d and %d\n", ib, ic);
		  exit(-1);
		  }
	       if (dd > 0) core_parallel[ib][k] = 1;
	       else core_parallel[ib][k] = 0;
	       if(otherprint) printf("core_parallel[%d][%d] = %d\n",
	          ib, k, core_parallel[ib][k]);
	       }
	    }
	 if(sheetpr) printf("ib %d one_free %d core_sheet %d\n", 
	    ib, one_free, core_sheet[ib]);
	 if(one_free > 0 && core_sheet[ib] < 0) {
	    core_sheet[ib] = core_sheets;
	    coreSheetSize[core_sheets] = 1;
	    id = ib;
	    if (core_edge[ib][0] >= 0)
	       ic = core_edge[ib][0];
	    else
	       ic = core_edge[ib][1];
	    while(ic != -1) {
	       if(sheetpr) printf("  ic %d core_sheet %d core_edges %d %d\n",
	          ic, core_sheet[ic], core_edge[ic][0], core_edge[ic][1]);
	       core_sheet[ic] = core_sheets;
	       ++coreSheetSize[core_sheets];
	       icsave = ic;
	       if(core_edge[ic][0] == id)
	          ic = core_edge[ic][1];
	       else if (core_edge[ic][1] == id)
	          ic = core_edge[ic][0];
	       else {
	          printf("unable to trace sheet with core_edge pointers\n");
		  exit(-1);
		  }
	       id = icsave;
	       }
	    ++core_sheets;
	    }
        printf("core_edges for strand %d are %d and %d\n",
	    ib, core_edge[ib][0], core_edge[ib][1]);
        }
       }
      }
     if(free_edges >= 2) {
        printf("There are %d free edges in BuildBeta. core_sheets %d\n",
	    free_edges, core_sheets);
	 }
     if(badcore) {
        printf("exited due to badcore\n");
	 exit(-1);
	 }
     printf("End of core processing\n");
     if(distpr) 
        for (strand = 0; strand < totalStrands; ++strand) 
	    printf("strand %d is in sheet %d\n", strand, core_sheet[strand]);
     } // core
  else
     core_sheets = 1;
/*
   Compute crosscount for the probability denominators in Ruczinski's thesis,
   equation 9.13, as 2 times the binomial coefficient giving the numbers of ways
   of choosing k crossing positions among the totalStrands-1 spaces between strands.
   This analysis is only appropriate for two sheets. For 3 or more, we must consider the
   choices of which sheet to cross into, so this number must be multiplied for each
   k by (core_sheets - 1)^k  to count the choices of which sheet to cross to.
*/
  if(core_sheets < 2)
     crosscount[0] = 1;
  else {
     crosscount[0] = 2 * (core_sheets - 1);
     num_fac = totalStrands - 1;
     den_fac = 1;
     for(k = 1; k < totalStrands; ++k) {
        crosscount[k] = crosscount[k-1] * num_fac  * (core_sheets - 1)/ den_fac;
        --num_fac;
        ++den_fac;
        }
     }

// Set up loop over strand distributions into sheets.

sheetCaseCount = 1;
for (i = 0; i < totalStrands - displaced_strands; ++i)
   sheetCaseCount *= core_sheets;

if(otherprint) printf("sheetCaseCount %d\n", sheetCaseCount);
// for (shi = 6; shi <= 6; ++shi)  
for (shi = 0; shi < sheetCaseCount; ++shi) 
 {                                          // sheet distribution cases

 temps = shi;
 for (k = 0; k < totalStrands; ++k) {
  if(core_edge[k][0] == -2)
    sh[k] = MAX_SHEETS;
  else {
    sh[k] = temps % core_sheets;
    temps /= core_sheets;
    }
  }
 if(distpr) {
    printf("begining sheet distribution case %d ", shi);
    for (k = 0; k < totalStrands; ++k) 
       printf("%d", sh[k]);
    printf("\n");
    }
 fflush(stdout);

/*
In this case, sh[k] says which beta sheet contains strand k,
sheetPosition[k] says what initial position it has in that sheet,
sheetPositionInverse[sheet][i] = k means sheetPosition[k] = i and sh[k] 
= sheet. These initial positions are modified by permutations, so that
position[sh[k]][sheetPosition[k]] describes its sequential position in the
sheet after a permutation. Then  k = positionInverse[sheet][i] gives the
strand index k so that 

position[sh[k]][sheetPosition[k]] = i.
*/

 for (i = 0; i <= MAX_SHEETS; ++i)
    betaCount[i] = 0;
 for (k = 0; k <  totalStrands; ++k) {
    i = betaCount[sh[k]];
    sheetPosition[k] = i;
    sheetPositionInverse[sh[k]][i] = k;
    ++betaCount[sh[k]];
    }
 if(distpr) printf("starting sheet distribution case %d %d sh ", shi,compatible_distributions);
 current_sheet = sh[0];
 crossings = 0;
 for (k = 0; k < totalStrands; ++k) {
    if(distpr) printf("%d", sh[k]);
    if(k > 0 && sh[k] != current_sheet && current_sheet != MAX_SHEETS &&
       sh[k] != MAX_SHEETS) {
	   ++crossings;
	   current_sheet = sh[k];
	   }
       }
/*
Compute probability of this sheet distribution in terms or the number of crossings.
See pages 142 to 144 of Ruczinski's PhD thesis.
*/
 if (crossings <= core_sheets - 1) {
    logistic = -3.372 + 0.653*(core_sheets);
    if(core_sheets > 2)
       logistic += -1.285;
    distribution_score = exp(logistic)/(1. + exp(logistic));
    }
 else {
    lambda = 0.306;
    for(k = 0; k < core_sheets; ++k)
       lambda *= 1.215;
    if(core_sheets > 2)
       lambda *= 0.629;
    numerator = exp(-lambda);
    denominator = numerator;
    for(k = 1; k < crossings; ++k) {
       numerator *= lambda/k;
	denominator += numerator;
	}
    distribution_score = numerator/denominator;
    }
 distribution_score /= (float)crosscount[crossings];

 if(distpr) printf(" crossings %d distribution_score %g\n", crossings, distribution_score);

 for (k = 0; k < totalStrands; ++k) {
   if(sh[k] != MAX_SHEETS && coreBeta[k] && sh[k] != core_sheet[k]) {

// core_edge of -2 is for shorter of two core strands hydrogen bonded to the same strand.

	if (distpr) {
	   printf("quit sheet distribution case %d since a core strand went into the wrong sheet; k %d sh %d core_sheet %d\n",
	   shi, k, sh[k], core_sheet[k]);
          fflush(stdout);
	   }
       goto quit_distribute;
	}
   }
 for (sheet = 0; sheet < core_sheets; ++sheet) {
    if(betaCount[sheet] > 10) {
	if(distpr) printf("quit sheet distribution case %d betaCount[%d] = %d\n",
	   shi, sheet, betaCount[sheet]);
       goto quit_distribute;
	}
    }
 ++compatible_distributions;
 if(otherprint) printf("compatible_distribution %d sorresponds to shi index %d: \n", compatible_distributions, shi);
 for (k = 0; k < totalStrands; ++k)
    if(otherprint) printf("%d", sh[k]);
 if(otherprint) printf(" distribution_score %g\n", distribution_score);

 if(crossings > max_crossings || distribute_only) goto quit_distribute;

 if(distpr) printf("trying sheet distribution below:\n");
 if(distpr) for (k = 0; k <  totalStrands; ++k) 
    printf(" k %d sheet %d\n", k, sh[k]);

 for (sheet = 0; sheet < core_sheets; ++sheet) { // sheet loop for probabilities
  if(distpr) {
     printf("sheet distribution case %d sheet %d\n", shi, sheet);
     }
  if(betaCount[sheet] < 5 && !do_all_topologies) {
    if(betaCount[sheet] == 2) {
     ntopology[sheet] = 2;
     for (i = 0; i < 2; ++i) {
	 bestTopologyUp[sheet][0][i] = 0;
        bestTopologyUp[sheet][1][i] = 1 - i; // since anti-parallel has higher probability
	 bestTopologyPosition[sheet][0][i] = 0;
	 bestTopologyPosition[sheet][1][i] = 1;
	 bestTopologyProbability[sheet][i] = P2[up[sheet][1]][helical][isLong[0]];
	 }
     }
    else if(betaCount[sheet] == 3) { 
     ntopology[sheet] = FIVE;
     ln = 0;
     twop = 1;
     for(i = betaCount[sheet] - 2; i >= 0; --i) {
        ln += twop*isLong[sheetPositionInverse[sheet][i]];
	 twop *= 2;
	 }
     for (i = 0; i < FIVE; ++i) 
        bestTopologyProbability[sheet][i] = 0.;
     for (i = 0; i < 12; ++i)
        for (j = 0; j < FIVE; ++j) 
	    if(P3[i][helical][ln] >= THRESHOLD &&
	       P3[i][helical][ln] > bestTopologyProbability[sheet][j]) {
	       for (k = FIVE - 1; k > j; --k) {
	          bestTopologyProbability[sheet][k] = bestTopologyProbability[sheet][k - 1];
		  bestM[k] = bestM[k - 1];
		  }
	       bestTopologyProbability[sheet][j] = P3[i][helical][ln];
	       bestM[j] = i;
	       break;
	       }
     for (j = 0; j < FIVE; ++j)
        for (i = 0; i < 3; ++i) {
	    M = bestM[j];
	    bestTopologyPosition[sheet][i][j] = Permute3[M][i];
	    bestTopologyUp[sheet][i][j] = Dir3[M][i];
	    }
     }
    else if(betaCount[sheet] == 4) {
     ln = 0;
     twop = 1;
     for(i = betaCount[sheet] - 2; i >= 0; --i) {
        ln += twop*isLong[sheetPositionInverse[sheet][i]];
	 twop *= 2;
	 }
     ntopology[sheet] = CaseNum[helical][ln];
     if(otherprint) printf("for 4 strand beta sheet, helical = %d, ln = %d, CaseNum = %d\n",
        helical, ln, CaseNum[helical][ln]);
     for (j = 0; j < ntopology[sheet]; ++j) {
        bestTopologyProbability[sheet][j] = Probability4[helical][ln][j];
	 for (i =0; i < 4; ++i) {
	    bestTopologyPosition[sheet][i][j] = Permute4[helical][ln][j][i];
	    bestTopologyUp[sheet][i][j] = Dir4[helical][ln][j][i];
	    }
	 }
     }
   if(has_core) {

//   Test to see if any are consistent with core specification.

     tempT = 0;
     for (kt = 0; kt < ntopology[sheet]; ++kt) {
        for (j = 0; j < betaCount[sheet]; ++j) {
	    position[sheet][j] = bestTopologyPosition[sheet][j][kt];
	    up[sheet][j] = bestTopologyUp[sheet][j][kt];
	    }
/*
In this case, sh[k] says which beta sheet contains strand k,
sheetPosition[k] says what initial position it has in that sheet,
sheetPositionInverse[sheet][i] = k means sheetPosition[k] = i and sh[k] 
= sheet. These initial positions are modified by permutations, so that
position[sh[k]][sheetPosition[k]] describes its sequential position in the
sheet after a permutation. Then  k = positionInverse[sheet][i] gives the
strand index k so that 

position[sh[k]][sheetPosition[k]] = i.
*/
	for (j = 0; j < betaCount[sheet]; ++j) {
	  i = position[sheet][j];
	  k = sheetPositionInverse[sheet][j];  // sheetPosition[k] = j;
	                                       // sh[k] = sheet;
	  positionInverse[sheet][i] = k;
	  }

       if(0) {
	   printf("sheet %d position ", sheet);
	   for (ib = 0; ib < betaCount[sheet]; ++ib) 
	      printf("%d ",position[sheet][ib]);
	   printf("\n");
	   }
	for (jb = 0; jb < betaCount[sheet]; ++jb) {
	  ib = positionInverse[sheet][jb];
	  if(coreBeta[ib])
	    for(j = 0; j < 2; ++j) {
	      ic = core_edge[ib][j];
	      if (ic >= 0) {
		 sb = sheetPosition[ib];
		 sc = sheetPosition[ic];
	         if(position[sheet][sc] != position[sheet][sb] - 1 &&
		    position[sheet][sc] != position[sheet][sb] + 1 ) {
		       if(0) {
		          printf(
		          "skipPermutation sheet %d ib %d sb %d ic %d sc %d permutation ",
		            sheet, ib, sb, ic, sc);
	                  for (i = 0; i < betaCount[sheet]; ++i)
	                     printf("%d ", position[sheet][i]);
	                  printf("\n");
			  }
		       goto skipTry;
		       }
	         }
	      }
	   }
	if(0) {
	  printf("permutation consistent with core for sheet of < 5 strands: ");
	  for (i = 0; i < betaCount[sheet]; ++i)
	     printf("%d ", position[sheet][i]);
	  printf("\n");
	  }
	
	for (ibb = 0; ibb < betaCount[sheet]; ++ibb) {
	   ib = positionInverse[sheet][ibb];
	   if(printskip) printf("sheet with < 5 strands; casec %d coreBeta[%d] = %d\n",
	      casec, ib, coreBeta[ib]);
	   if(coreBeta[ib])
	      for(j = 0; j < 2; ++j) {
	         ic = core_edge[ib][j];
	         if (ic >= 0) {
		   pib = position[sheet][sheetPosition[ib]];
	           if(printskip > 1) printf(
		      "testing consistancy ib %d ic %d pib %d pic core_parallel %d up %d %d\n",
		      ib, ic, pib, position[sheet][sheetPosition[ic]], core_parallel[ib][j],
		      up[sheet][pib], up[sheet][pib + 1]);
		   if(position[sheet][sheetPosition[ic]] == pib + 1) 
		     if((core_parallel[ib][j] && up[sheet][pib] != up[sheet][pib + 1]) ||
		       (!core_parallel[ib][j] && up[sheet][pib] == up[sheet][pib + 1]) ) {
	                  if(printskip) {
	                     printf("permutation  ");
	                     for (i = 0; i < betaCount[sheet]; ++i)
	                        printf("%d ", position[sheet][i]);
			     printf(" up ");
	                     for (i = 0; i < betaCount[sheet]; ++i)
			        printf("%d ",up[sheet][i]);
	                     printf(" skipped because up directions disagree with core\n");
	                     }
		         goto skipTry;
			 }
		   }
	         }
	   }
// Successfully passed consistency tests.
// OK to overwrite arrays as below, because tempT <= kt;

      for (j = 0; j < betaCount[sheet]; ++j) {
	    bestTopologyPosition[sheet][j][tempT] = position[sheet][j];
	    bestTopologyUp[sheet][j][tempT] = up[sheet][j];
	    }
      ++tempT;
skipTry: ;  // Failed consistency tests.
      }
    ntopology[sheet] = tempT;
    if(otherprint) printf("ntopology[%d] = %d from tested default cases, betaCount %d\n",
       sheet, ntopology[sheet], betaCount[sheet]);
    }
   }  // betaCount[sheet] < 5
  if(betaCount[sheet] <= 10 &&
    (betaCount[sheet] >= 5 || ntopology[sheet] == 0 || do_all_topologies)) {

     ntopology[sheet] = 0;
     caseCount = twoPower[betaCount[sheet] - 1];
     for (j = 0; j < MAXTOP+1; ++j)
        bestTopologyProbability[sheet][j] = 0.;
     up[sheet][0] = 1;
     half = (betaCount[sheet]+1)/2;
     if(betaCount[sheet] < 5) goto skipMakeKnL;

//  Process permutations in lexicographic (or numerical ) order.
//  First generate counts knL

     for(i = 0; i < betaCount[sheet]; ++i)
       for(j = 0; j < betaCount[sheet]; ++j)
	   for(k = 0; k < betaCount[sheet]; ++k)
	      for(l = 0; l < betaCount[sheet]; ++l)
	         for (m = 0; m < half; ++m)
		    knL[i][j][k][l][m] = 0;
     count = 0;
     for (i = 0; i < betaCount[sheet]; ++i)
       position[sheet][i] = i;

permutationLoop0: ;
	if(position[sheet][0] >= half) {
	   if(printskip0) {
	      printf("permutation  ");
	      for (i = 0; i < betaCount[sheet]; ++i)
	         printf("%d ", position[sheet][i]);
	      printf(" skipped because first strand not on left\n");
	      }
	   goto skipP;
	   }
	if(betaCount[sheet]%2 &&
	  position[sheet][0] == half-1 && position[sheet][1] >= half) {
	   if(printskip0) {
	      printf("permutation  ");
	      for (i = 0; i < betaCount[sheet]; ++i)
	         printf("%d ", position[sheet][i]);
	      printf(" skipped because second strand not on left\n");
	      }
	   goto skipP;
	   }
       for (casec = 0; casec < caseCount; ++casec) {
          tempc = casec;
          for(k = 1; k < betaCount[sheet]; ++k) {
            up[sheet][k] = tempc % 2;
            tempc /= 2;
	     }
	   L = 1;
          J = 0;
	   Js = 0;
	   Pp = 0;
	   Ps = 0;
	   Ns = 0;
	   for (i = 0; i < betaCount[sheet] - 1; ++i) {
	     k = sheetPositionInverse[sheet][i];
	     if(isLong[k] == 0) {
	        L = 0;
	        ++Ns;
		}
            if(position[sheet][i+1] != position[sheet][i] - 1 &&
               position[sheet][i+1] != position[sheet][i] + 1 ) {
               ++J;
               if(isLong[k] == 0) ++Js;
               }
            if(up[sheet][position[sheet][i+1]] == up[sheet][position[sheet][i]]) {
               ++Pp;
               if(isLong[k] == 0) ++Ps;
               }
	     }
	   ++knL[Pp][Ps][J][Js][position[sheet][0]];
	   ++count;
	   if(pknl > 1) printf("incremented knL[%d][%d][%d][%d][%d]",
	                    Pp, Ps, J ,Js, position[sheet][0]);
	   if(pknl > 1) printf(" for position %d %d %d %d %d  up %d %d %d %d %d\n",
	      position[sheet][0], position[sheet][1], position[sheet][2], position[sheet][3], position[sheet][4],
	      up[sheet][0], up[sheet][1], up[sheet][2], up[sheet][3], up[sheet][4]);
	   }
skipP: ;
	for (j = betaCount[sheet] - 1; j > 0; --j) 
	  if (position[sheet][j-1] < position[sheet][j]) {
	    vmin = 100000;
	    for (k = j; k < betaCount[sheet]; ++k) 
	       if(position[sheet][k] > position[sheet][j-1] && position[sheet][k] < vmin) {
	          kmin = k;
		  vmin = position[sheet][k];
		  }
	    if(vmin >= 100000) {
	       printf("problem with permutation generator\n");
	       exit(-1);
	       }
	    temp = position[sheet][kmin];
	    position[sheet][kmin] = position[sheet][j-1];
	    position[sheet][j-1] = temp;
	    qsort(&(position[sheet][j]), betaCount[sheet] - j, sizeof(int), comparePosition);
	    goto permutationLoop0;
	    }
     if(otherprint) printf("first pass count is %d\n", count);
skipMakeKnL: ;

     count = 0;
     sum = 0.;
     allcore = 1;
     for (i = 0; i < betaCount[sheet]; ++i)
       position[sheet][i] = i;

permutationLoop: ;

// Make topology consistent with core region specification

/*
In this case, sh[k] says which beta sheet contains strand k,
sheetPosition[k] says what initial position it has in that sheet,
sheetPositionInverse[sheet][i] = k means sheetPosition[k] = i and sh[k] 
= sheet. These initial positions are modified by permutations, so that
position[sh[k]][sheetPosition[k]] describes its sequential position in the
sheet after a permutation. Then  k = positionInverse[sheet][i] gives the
strand index k so that 

position[sh[k]][sheetPosition[k]] = i.
*/
	for (j = 0; j < betaCount[sheet]; ++j) {
	  i = position[sheet][j];
	  k = sheetPositionInverse[sheet][j];  // sheetPosition[k] = j;
	                                       // sh[k] = sheet;
	  positionInverse[sheet][i] = k;
	  }
	num_core_strands[sheet] = 0;
       for (j = 0; j < betaCount[sheet]; ++j) {
	   ib = positionInverse[sheet][j];
	   if (!coreBeta[ib]) 
	      allcore = 0;
	   else
	      ++num_core_strands[sheet];
	   }
	pos0 = position[sheet][0];
	pos1 = position[sheet][1];
	if (printskip) printf("permutationLoop  ");
	if((num_core_strands[sheet] <= 1 || allcore) && pos0 >= half) {
	   if (printskip) printf("skipped because pos0 >= half\n");
	   goto skipPermutation;
	   }
	if((num_core_strands[sheet] <= 1 || allcore) && betaCount[sheet]%2 && pos0 == half-1 && pos1 >= half) {
	   if (printskip) printf("skipped because pos0 == half-1 && pos1 >= half\n");
	   goto skipPermutation;
	   }

       if(printskip) {
	   printf("sheet %d position ", sheet);
	   for (ib = 0; ib < betaCount[sheet]; ++ib) 
	      printf("%d ",position[sheet][ib]);
	   printf("\n");
	   }
	for (jb = 0; jb < betaCount[sheet]; ++jb) {
	  ib = positionInverse[sheet][jb];
	  if(coreBeta[ib])
	    for(j = 0; j < 2; ++j) {
	      ic = core_edge[ib][j];
	      if (ic >= 0) {
		 sb = sheetPosition[ib];
		 sc = sheetPosition[ic];
	         if(position[sheet][sc] != position[sheet][sb] - 1 &&
		    position[sheet][sc] != position[sheet][sb] + 1 ) {
		       if(printskip) printf(
		        "skipPermutation because strand adjacency disagrees with core; sheet %d ib %d sb %d ic %d sc %d\n",
		          sheet, ib, sb, ic, sc);
		       goto skipPermutation;
		       }
	         }
	      }
	   }
	if(printskip) {
	  printf("permutation ");
	  for (i = 0; i < betaCount[sheet]; ++i)
	     printf("%d ", position[sheet][i]);
	  printf("\n");
	  }
	
       for (casec = 0; casec < caseCount; ++casec) {  // up cases loop
          tempc = casec;
          for(k = 1; k < betaCount[sheet]; ++k) {
            up[sheet][k] = tempc % 2;
            tempc /= 2;
	     }
	   for (ibb = 0; ibb < betaCount[sheet]; ++ibb) {
	     ib = positionInverse[sheet][ibb];
	     if(coreBeta[ib])
	       for(j = 0; j < 2; ++j) {
	         ic = core_edge[ib][j];
	         if (ic >= 0) {
		   pib = position[sheet][sheetPosition[ib]];
	           if(printskip > 1) printf(
		      "testing consistency ib %d ic %d pib %d pic core_parallel %d up %d %d\n",
		      ib, ic, pib, position[sheet][sheetPosition[ic]], core_parallel[ib][j],
		      up[sheet][pib], up[sheet][pib + 1]);
		   if(position[sheet][sheetPosition[ic]] == pib + 1) 
		     if((core_parallel[ib][j] && up[sheet][pib] != up[sheet][pib + 1]) ||
		       (!core_parallel[ib][j] && up[sheet][pib] == up[sheet][pib + 1]) ) {
	                  if(printskip) {
	                     printf("permutation  ");
	                     for (i = 0; i < betaCount[sheet]; ++i)
	                        printf("%d ", position[sheet][i]);
			     printf(" up ");
	                     for (i = 0; i < betaCount[sheet]; ++i)
			        printf("%d ",up[sheet][i]);
	                     printf(" skipped because up directions disagree with core\n");
	                     }
		          goto skipUp;
			  }
		   }
	         }
	     }

	  if(betaCount[sheet] < 5)
	      ppp = 1.;  // Equal meaningless probabilities. We could later
	                 // update the needed arrays from Ruscinski's PDB data.
	  else {  // compute Ruczinski score
	   L = 1;
          J = 0;
	   Js = 0;
	   Pp = 0;
	   Ps = 0;
	   Ns = 0;
	   for (i = 0; i < betaCount[sheet] - 1; ++i) {
	     k = sheetPositionInverse[sheet][i];
	     if(isLong[k] == 0) {
	        L = 0;
	        ++Ns;
		if(0) printf("i %d Ns %d\n", i, Ns);
		}
	     if( position[sheet][i+1] != position[sheet][i] - 1 &&
	         position[sheet][i+1] != position[sheet][i] + 1 ) {
	        ++J;
	        if(isLong[k] == 0 && sh[k+1] == sh[k]) ++Js;
	        }
	     if(up[sheet][position[sheet][i+1]] == up[sheet][position[sheet][i]]) {
	        ++Pp;
	        if(sh[k+1] == sh[k] && isLong[k] == 0) ++Ps;
	        if(medium && sh[k+1] == sh[k] && isMedium[k] == 0 &&
		   (position[sheet][i+1] == position[sheet][i] - 1 ||
		    position[sheet][i+1] == position[sheet][i] + 1 ) ) {
	           if(printskip) {
	              printf("permutation  ");
	              for (i = 0; i < betaCount[sheet]; ++i)
	                 printf("%d ", position[sheet][i]);
		      printf(" up ");
	              for (i = 0; i < betaCount[sheet]; ++i)
		         printf("%d ",up[sheet][i]);
	              printf(" skipped because medium loop joins parallel strands");
	              }
		   goto skipUp;
		   }
	        }
	     }

// get factor pFirst = P(F | n, h) from array
// P(F | n, h) = FnH[n-5][h][F], where F is first position, and H is helical

//  Flip pos0 if necessary to make it in the first half.
//	if(!has_core && pos0 >= half) goto skipPermutation;
//	if(!has_core && betaCount[sheet]%2 && pos0 == half-1 && pos1 >= half)

	   if(pos0 >= half ||
	      (betaCount[sheet]%2 && pos0 == half-1 && pos1 >= half) )
	        pos0 = betaCount[sheet] - 1 - pos0;
	   
	   n = betaCount[sheet] - 5;
          pFirst = FnH[n][helical][pos0];
	   sumF = 0;
	   for(k = 0; k <= half; ++k)
	      sumF += FnH[n][helical][k];

// get factor pPpJ = P(Pp, J | n, H, L, F) from arrray
// float Pcount[6][7][4][2][2][6];
// Pcount[n][Pp][J][H][L][F] is count for Pp, J given n, H, L, F

	   pPpJ = Pcount[n][PpTable[n][Pp]][JTable[n][J]][helical][L][position[sheet][0]];

// The next line is to force all topologies to be cataloged, and sorted by probability.
// Use enough_topologies to limit the number that will actually be tried for zipping.

	   if(pPpJ == 0.) pPpJ = .00001;
	   pl = Pp + Ns - (betaCount[sheet] - 1);
	   if (pl < 0) pl = 0;
	   pu = Pp;
	   if (Ns < Pp) pu = Ns;

// double binomialDistribution(float p, int i, int n) 

	   pparpair = binomialDistribution(pParPair[n][helical], Ps - pl, pu - pl);
	   if (pknl && pparpair == 0)
	      printf("pparpair = 0, from binomialDistribution(%f, %d, %d)\n",
	         pParPair[n][helical], Ps - pl, pu - pl);
	   jl = J + Ns - (betaCount[sheet] - 1);
	   if (jl < 0) jl = 0;
	   ju = J;
	   if (Ns < J) ju = Ns;
/*
	   if(betaCount[sheet] < 7)
	      pj = pJump[0][helical];
	   else
	      pj = pJump[1][helical];
*/
	   pj = pJump[n][helical];
	   pjump =  binomialDistribution(pj, Js - jl,  ju - jl);

	   ppp = (double)(pFirst * pPpJ) * pparpair * pjump;
	   if (knL[Pp][Ps][J][Js][pos0] != 0)
	       ppp /= (double)knL[Pp][Ps][J][Js][pos0];

	   if(pknl) {
	      printf("ppp %12.8f  knL %d  Pp %d Ps %d J %d Js %d pos0 %d  up 1 ",
	         (float)ppp, knL[Pp][Ps][J][Js][pos0], Pp, Ps, J, Js, pos0);
             for(k = 1; k < betaCount[sheet]; ++k)
                printf("%d ", up[sheet][k]);
	      printf(" pFirst %g pPpJ %g pparpair %g pjump %g\n",
	         pFirst, pPpJ, pparpair, pjump);
	      }
	   }

          if(0 && ntopology[sheet] == try_topologies - 1) {
	      printf("early termination of PermutationLoop since ntopology[%d] %d == try_topologies - 1 %d\n",
	         sheet, ntopology[sheet], try_topologies - 1);
             goto donePermutationLoop; // early termination
             }

	   if(ppp > 0 &&
	      ppp == bestTopologyProbability[sheet][ntopology[sheet] - 1] &&
	      ppp == bestTopologyProbability[sheet][0]) {  // equal proabilities
	      if(ntopology[sheet] < try_topologies - 1){
	         if(printskip) {
	            printf("equal probability permutation  ");
	            for (i = 0; i < betaCount[sheet]; ++i)
	               printf("%d ", position[sheet][i]);
		    printf(" up  ");
	            for (i = 0; i < betaCount[sheet]; ++i)
		       printf("%d ",up[sheet][i]);
	            printf(" not skipped; ntopology %d ppp %g\n", ntopology[sheet], ppp);
	            }
	         bestTopologyProbability[sheet][ntopology[sheet]] = ppp;
		 for(strand = 0; strand < betaCount[sheet]; ++strand) {
		    bestTopologyPosition[sheet][strand][ntopology[sheet]] = position[sheet][strand];
		    bestTopologyUp[sheet][strand][ntopology[sheet]] = up[sheet][strand];
		    }
	         ++ntopology[sheet];
	         }
	      else {
	        if(printskip) {
	           printf("permutation  ");
	           for (i = 0; i < betaCount[sheet]; ++i)
	              printf("%d ", position[sheet][i]);
		   printf(" up ");
	           for (i = 0; i < betaCount[sheet]; ++i)
		      printf("%d ",up[sheet][i]);
	           printf(" skipped because of too many equal probabilities\n");
	           }
		 goto skipUp; // early termination for too many equal probabilities
		 }
	      }   // equal probabilities
	  else {  // not equal probabilities
             for (j = 0; j < ntopology[sheet] + 1; ++j) {  // loop to insert new topology
                if(ppp > bestTopologyProbability[sheet][j] &&
		       ntopology[sheet] < try_topologies - 1) {  // actualy insert
	           if(printskip) {
	              printf("permutation  ");
	              for (i = 0; i < betaCount[sheet]; ++i)
	                 printf("%d ", position[sheet][i]);
		      printf(" up  ");
	              for (i = 0; i < betaCount[sheet]; ++i)
		         printf("%d ",up[sheet][i]);
	              printf(" not skipped; ntopology %d ppp %g\n",ntopology[sheet], ppp);
	              }
		   ++ntopology[sheet];
	           for (k = ntopology[sheet] - 1; k > j; --k) {
	              bestTopologyProbability[sheet][k] = bestTopologyProbability[sheet][k - 1];
		      for(strand = 0; strand < betaCount[sheet]; ++strand) {
		        bestTopologyPosition[sheet][strand][k] = 
			   bestTopologyPosition[sheet][strand][k - 1];
			bestTopologyUp[sheet][strand][k] = bestTopologyUp[sheet][strand][k - 1];
			}
		      }
		   for(strand = 0; strand < betaCount[sheet]; ++strand) {
		      bestTopologyPosition[sheet][strand][j] = position[sheet][strand];
		      bestTopologyUp[sheet][strand][j] = up[sheet][strand];
		      }
		   bestTopologyProbability[sheet][j] = ppp;
	           break;
		   } // actually insert
	       }  // loop to insert new topology
	     }  // not equal probabilities
	   sum += ppp;
	   if (betaCount[sheet] >= 5) {
	      if (ppp > maxppp) {
	         maxppp = ppp; 
	         maxcount = 1;
	         maxknL = knL[Pp][Ps][J][Js][position[sheet][0]];
	         }
	      else if (ppp == maxppp)
	         ++maxcount;
	      }
	   ++count;

skipUp: ;
          } // up cases loop
skipPermutation: ;
	for (j = betaCount[sheet] - 1; j > 0; --j) 
	  if (position[sheet][j-1] < position[sheet][j]) {
	    vmin = 100000;
	    for (k = j; k < betaCount[sheet]; ++k) 
	       if(position[sheet][k] > position[sheet][j-1] && position[sheet][k] < vmin) {
	          kmin = k;
		  vmin = position[sheet][k];
		  }
	    if(vmin >= 100000) {
	       printf("problem with permutation generator\n");
	       exit(-1);
	       }
	    temp = position[sheet][kmin];
	    position[sheet][kmin] = position[sheet][j-1];
	    position[sheet][j-1] = temp;
	    qsort(&(position[sheet][j]), betaCount[sheet] - j, sizeof(int), comparePosition);
	    goto permutationLoop;
           }
donePermutationLoop: ;
     if(otherprint) printf("sum %g  count %d maxppp %g, maxcount %d maxknL %d\n",
       sum, count, maxppp, maxcount, maxknL);
     } 
  else if(betaCount[sheet] >= 5) {
     printf("Can currently handle only up to 10 beta strands per sheet.\n");
     exit(-1);
     }
  printf("Number of topology cases: ntopology[%d] =  %d\n",
     sheet, ntopology[sheet]);
  if(printop) 
   for(j = 0; j < ntopology[sheet]; ++j) {
    printf("j %d position ", j);
    for (k = 0; k < betaCount[sheet]; ++k) 
       printf("%d ", bestTopologyPosition[sheet][k][j]);
    printf(" up ");
    for (k = 0; k < betaCount[sheet]; ++k) 
       printf("%d ", bestTopologyUp[sheet][k][j]);
    printf(" ppp %g\n", bestTopologyProbability[sheet][j]);
    }
  if(printop) fflush(stdout);

/* this must be moved to act at the correct sheet after topologies are known
// Flatten strands at the beginning if shortening is not done per case.

  if(shorten == 0 && optimized_angles == 0 && flatten) {
       for(i = 0; i < betaCount[sheet]; ++i) {
	    Protein::StructureSelector flatteningStrand = state->protein->pickStructure(betaPiece[i]);
	    state->interactor->selectStructure(flatteningStrand);
           state->interactor->clearCoilRegions();
           numResidues = state->interactor->getStructure().getNumResidues();
	    if(0) printf("flattening %d residues in strand %d\n", numResidues, i);
           if(numResidues > 2 && state->interactor->isBetaStrand())
               {
               MD::Scalar* phis=new MD::Scalar[numResidues];
               MD::Scalar* psis=new MD::Scalar[numResidues];
		if(optimized_angles == 0 || numResidues < 5)
                  for (j =0;j<numResidues;++j)
                     {
                     phis[j]=Math::rad(flatPhi);
                     psis[j]=Math::rad(flatPsi);
                     }
               undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
               state->interactor->setDihedralAngles(phis,psis);
               delete[] phis;
               delete[] psis;
               undoBuffer.finishInteraction();
               state->proteinRenderer->updateProtein();
               if(state->energyCalculator!=0)
                       state->energyCalculator->updateProtein();
               }
	   }
	// state->proteinRenderer->updateStructureFlags();
       }
*/
    }  // sheet loop for probabilities

//  Find best topology probilities as products of per-sheet probabilities.

  topologies = 0;
  multi_sheet_topology_cases = 1;
  multi_sheet_topologies = 0;
  for (sheet = 0; sheet < core_sheets; ++sheet)
     multi_sheet_topology_cases *= ntopology[sheet];
  for (i = 0; i <= MULTI_SHEET_TOPOLOGIES; ++i) 
     bestTotalProbability[i] = 0;

  if(otherprint) printf("multi_sheet_topology_cases %d\n", multi_sheet_topology_cases);
  for (sheetop = 0; sheetop < multi_sheet_topology_cases; ++sheetop) {
   prob = 1;
   tsheet = sheetop;
   for (sheet = 0; sheet <  core_sheets; ++sheet) {
     j = tsheet % ntopology[sheet];
     tsheet = tsheet / ntopology[sheet];
     prob *= bestTopologyProbability[sheet][j];
     }
   for(k = 0; k < multi_sheet_topologies + 1; ++k) {	
     if (prob > bestTotalProbability[k]) {
       tsheet = sheetop;
	if(multi_sheet_topologies < MULTI_SHEET_TOPOLOGIES) 
	  ++multi_sheet_topologies;
       for(l = multi_sheet_topologies - 1; l > k; --l) {
	  bestTotalProbability[l] = bestTotalProbability[l-1];
	  for (sheet = 0; sheet <  core_sheets; ++sheet)
	     multi_sheet_topology[l][sheet] =
	        multi_sheet_topology[l-1][sheet];
	  }
	bestTotalProbability[k] = prob;
       for (sheet = 0; sheet < core_sheets; ++sheet) {
         j = tsheet % ntopology[sheet];
         tsheet = tsheet / ntopology[sheet];
         multi_sheet_topology[k][sheet] = j;
	  }
	break;
       }
     }
   }

// Loop through selected topologies, and find best all-sheet alignments.

  start_topology = 0;
  end_topology = multi_sheet_topologies - 1;
  // start_topology = 2;
  //end_topology = 0;
  for (kt = start_topology; kt <= end_topology; ++kt) {  // multi_sheet_topologies
  if(otherprint && !list_topology_only)
     printf("starting multi_sheet_topology %d probability %f\n",
     kt, bestTotalProbability[kt]);
  if (bestTotalProbability[kt] > 0) {  // positive probability
  foundThisTopology = 0;
  zipcount = 0;
  if (read_anew) {
     Protein::ChainAtom** atoms=state->protein->getAtomPointers();
     for(int i=0;i<state->protein->getNumAtoms();++i)
         atoms[i]->setPosition(save_coords[i]);
     }

  for (sheet = 0; sheet < core_sheets; ++sheet) {
   jt = multi_sheet_topology[kt][sheet];
   if(otherprint && !list_topology_only) printf("sheet %d topology %d \n", sheet, jt);
   for (strand = 0; strand < betaCount[sheet]; ++strand) {
      position[sheet][strand] = bestTopologyPosition[sheet][strand][jt];
      up[sheet][strand] = bestTopologyUp[sheet][strand][jt];
      if(0) printf("topology %d sheet %d strand %d position %d up %d\n",
         kt, sheet, strand, position[sheet][strand], up[sheet][strand]);
      }
   }
  if(otherprint && !list_topology_only) printf("\n");
  for (i = 0; i < totalStrands; ++i) {
     sheet = sh[i];
     k = position[sheet][sheetPosition[i]];
     positionInverse[sheet][k] = i;
     saved_zips[i][0] = 0;
     saved_zips[i][1] = 0;
     }
  if (list_topology_only) {
   printf("topology %d", kt);
   for (sheet = 0; sheet < core_sheets; ++sheet) {
     printf(" sheet %d position ", sheet);
     for (k = 0; k < betaCount[sheet]; ++k)
        printf("%d", positionInverse[sheet][k] + 1);
     printf(" up ");
     for (k = 0; k < betaCount[sheet]; ++k)
        printf("%d", up[sheet][k]);
     }
   printf(" probability %g\n", bestTotalProbability[kt]);
   continue;
   }

  for(strand = 0; strand < totalStrands; ++strand) {
     tempPlaced[strand] = 0;
     useHairpin[strand] = 0;
     }

  for (sheet = 0; sheet < core_sheets; ++sheet)  {
     if(otherprint) printf("sheet %d position inverse ", sheet);
     mincore[sheet] = 10000;
     maxcore[sheet] = -10;
     for(strand = 0; strand < betaCount[sheet]; ++strand) {
        i = positionInverse[sheet][strand];
	 if(otherprint) printf("%d ", i);
        if(coreBeta[i]) {
           if(strand < mincore[sheet]) mincore[sheet] = strand;
           if(strand > maxcore[sheet]) maxcore[sheet] = strand;
           }
        }
     if(otherprint) printf("  up ");
     for(strand = 0; strand < betaCount[sheet]; ++strand) 
        if(otherprint) printf("%d ", up[sheet][strand]);
     jt = multi_sheet_topology[kt][sheet];
     if(otherprint) printf("\n");
     if(otherprint) fflush(stdout);

// Only need to generate alignment cases if this is the first try
// or if this sheet topology is different than the last one tried

     if(otherprint) printf("  kt %d jt %d multi_sheet_topology[%d][%d] = %d\n",
        kt, jt, kt-1, sheet, multi_sheet_topology[kt-1][sheet]);
     if(list_topology_only) {
        continue;
	 }
     if (kt == start_topology || (kt > start_topology && (jt != multi_sheet_topology[kt-1][sheet] || bestTotalProbability[kt-1] == 0) )) {
        if (bond_angle_check) checkBondAngles(4);
	 slowTrans = 0;
        sfound[sheet] = findCaseBestFOUR(sheet);
	 if(printhair) {
	    printf("saved_zips: ");
	    for (i = 0; i < totalStrands; ++i)
	       printf("%d %d   ", saved_zips[i][0], saved_zips[i][1]);
	    printf("\n");
	    }
	 if(offlineBuildBeta == 0  && interact > 1) {
	    fprintf(stderr, "after findCaseBestFOUR\a\n");
           printf("type r for return, other character to continue ");
           if(getchar() == 'r') {
	    state->proteinRenderer->updateStructureFlags();
	       return;
	       }
	    }
        if (bond_angle_check) checkBondAngles(5);
	 if(otherprint) printf("  findCaseBestFOUR returned sfound[sheet %d] = %d\n",
	    sheet, sfound[sheet]);
	 if(otherprint) printf("useHairpin ");
        for (strand = 0; strand < totalStrands; ++strand)
	    if(otherprint) printf(" %d", useHairpin[strand]);
	 if(otherprint) printf("\n");
 	 }
     else {
        if(otherprint) printf("findCaseBestFOUR skipped on sheet %d probability[kt - 1] %g\n", sheet,  bestTotalProbability[kt-1]);
	 }
     slowTrans = 0;
     if(sfound[sheet] == -3) {
        fprintf(stderr, "after successful test zipping\a\n");
        printf("type r for return, other character to continue ");
        if(getchar() == 'r') {
           state->proteinRenderer->updateStructureFlags();
           return;
           }
	 }
     if( sfound[sheet] <= 0) {
	 ++no_zip;
	 if(0) for(i = sheet + 1; i < core_sheets; ++i)
	    sfound[i] = 0;
	 if(otherprint) 
	    printf("no zippable alignments found for sheet %d\n", sheet);
        goto bad_topology;
	 }
     }

  sheet_alignment_cases = 1;
  for (sheet = 0; sheet < core_sheets; ++sheet)
     sheet_alignment_cases *= sfound[sheet];
  for (i = 0; i < multi_sheet_alignments; ++i) 
     bestTotalScore[i] = LARGE;
  maxalign = -1;
  if(otherprint) printf("Total sheet_alignment_cases %d sfound %d %d multi_sheet_alignments %d\n",
     sheet_alignment_cases, sfound[0], sfound[1], multi_sheet_alignments);

  for (sheetalign = 0; sheetalign < sheet_alignment_cases; ++sheetalign) {
   score = 0.;
   tsheet = sheetalign;
   for (sheet = 0; sheet <  core_sheets; ++sheet) {
     j = tsheet % sfound[sheet];
     tsheet = tsheet / sfound[sheet];
     score += bestTotalE[sheet][j];
     }
   for(k = 0; k < multi_sheet_alignments; ++k) {	
     if (score < bestTotalScore[k]) {
       tsheet = sheetalign;
       for(l = multi_sheet_alignments - 1; l > k; --l) {
	  bestTotalScore[l] = bestTotalScore[l-1];
	  if(bestTotalScore[l] < .5*LARGE && l > maxalign)
	     maxalign = l;
	  for (sheet = 0; sheet <  core_sheets; ++sheet)
	     multi_sheet_alignment[l][sheet] =
	        multi_sheet_alignment[l-1][sheet];
	  }
	bestTotalScore[k] = prob;
	if (k > maxalign) maxalign = k;
       for (sheet = 0; sheet < core_sheets; ++sheet) {
         j = tsheet % sfound[sheet];
         tsheet = tsheet / sfound[sheet];
         multi_sheet_alignment[k][sheet] = j;
	  if( j >= sheet_alignment_cases)
	     if(otherprint) printf("j >= sheet_alignment_cases\n");
	  }
	break;
       }
     }
     if(shpr) printf("multi_sheet_alignments %d j %d k %d result %d %d %d %d %d %d %d %d\n",
       multi_sheet_alignments, j, k, multi_sheet_alignment[0][0],
	multi_sheet_alignment[1][0], multi_sheet_alignment[2][0],
	multi_sheet_alignment[3][0], multi_sheet_alignment[4][0],
	multi_sheet_alignment[5][0], multi_sheet_alignment[6][0],
	multi_sheet_alignment[7][0]);
   }

// Loop through selected alignments and odd/even cases


  alignments = 0;
  for (lt = 0; lt <= maxalign ; ++lt) { // multi_sheet_alignments
   for (mt = 0; mt < twoPower[2*core_sheets]; ++mt) { // odd-even cases
    mtt = mt; 
    opened_helices = 0;

// Early detection of cases to be skipped

    if(has_core) {  // has_core
     if(early_skip_print) {
	 printf("sh: sheet for each strand: ");
        for (strand = 0; strand < totalStrands; ++strand)
	    printf("%d ", sh[strand]);
	 printf("\n");
	 }
     for(strand = 0; strand < totalStrands; ++strand)
	if(coreBeta[strand])
          placed[strand] = 1;
	else
          placed[strand] = 0;
     for (sheet = 0; sheet < core_sheets; ++sheet) { // sheets early
       ic = multi_sheet_alignment[lt][sheet];
       od = mtt % 4;
	if(0 && oddprint) printf(
	   "early detection mt %d sheet %d mtt %d od %d\n",
	   mt, sheet, mtt, od);
	mtt /= 4;
       if(early_skip_print) {
	   printf("position ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", position[sheet][strand]);
	   printf("\npositionInverse ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", positionInverse[sheet][strand]);
	   printf("\nplaced positionInverse ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", placed[positionInverse[sheet][strand]]);
	   printf("\nup ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", up[sheet][strand]);
	   printf("\n");
	   }

	 found = 0;
        for(strand = 0; strand < betaCount[sheet]; ++strand) {
           i = positionInverse[sheet][strand];
	    if(!coreBeta[i])
	       found = 1;
	    }

// skip case if there are no movable strands in this sheet and od >= 1.

        if(found == 0 && od >= 1) {
	       if (early_skip_print) printf("skippedCase1 sheet %d\n", sheet);
	       ++skippedCase1[sheet];
	       goto skipCase;
	       }

	 if(0 && oddprint) printf("sheet %d  mincore %d maxcore %d\n",
	       sheet, mincore[sheet], maxcore[sheet]);
	       
// skip case if core strands are not consecutive (along sheet)

	 if(maxcore[sheet] - mincore[sheet] + 1 != coreSheetSize[sheet])
	       {
	       if (early_skip_print) printf("skippedCase2 sheet %d\n", sheet);
	       if (early_skip_print)
	          printf("sheet %d  mincore %d maxcore %d coreSheetSize %d\n",
	             sheet, mincore[sheet], maxcore[sheet], coreSheetSize[sheet]);
	       ++skippedCase2[sheet];
	       goto skipCase;
	       }

/* skip case if only one edge loop and od >= 2. Eventual use of od is:

	 for (lp = 0; lp < loops; ++lp) 
         odd = od%2;
	  od = od/2;
*/
	 if (maxcore[sheet] < 0 || mincore[sheet] == 0 || 
	    maxcore[sheet] == betaCount[sheet] - 1) { 
	    loops = 1;
	    if (od >= 2) {
	       if (early_skip_print) printf("skippedCase3 sheet %d\n", sheet);
	       ++skippedCase3[sheet];
	       goto skipCase;
	       }
	    }

	 }  // sheets early
      } // has_core
    else   // no core sheets early
	    if (mt >= 2) {
	       if (early_skip_print) printf("skippedCase3 sheet %d\n", sheet);
	       ++skippedCase3[sheet];
	       goto skipCase;
	       }


    shortcount = 0;
    longcount = 0;
    alignments = 0;
    mtt = mt; 
    for(strand = 0; strand < totalStrands; ++strand)
	  if(coreBeta[strand])
            placed[strand] = 1;
	  else
            placed[strand] = 0;

    if (bond_angle_check) checkBondAngles(1);
    for (sheet = 0; sheet < core_sheets; ++sheet) { // sheets
       centers = 0;
	ic = multi_sheet_alignment[lt][sheet];
       od = mtt % 4;
	mtt /= 4;
       if(otherprint) printf("sheet %d kt %d lt %d mt %d jt %d  od %d  ic %d\n",
          sheet, kt, lt, mt, jt, od, ic);
       if(otherprint) printf("succeeded %d  gave up %d  skippedCase %d %d %d %d no_zip %d zipProline %d stretch_skipped %d\n",
          succeeded, gaveup, 
	   skippedCase1[sheet], skippedCase2[sheet], skippedCase3[sheet], skippedCase4[sheet],
	   no_zip, zipProline, stretch_skipped);
       if(shpr) {
	   printf("position ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", position[sheet][strand]);
	   printf("\npositionInverse ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", positionInverse[sheet][strand]);
	   printf("\nplaced positionInverse ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", placed[positionInverse[sheet][strand]]);
	   printf("\nup ");
          for (strand = 0; strand < betaCount[sheet]; ++strand)
	      printf(" %d", up[sheet][strand]);
	   printf("\nuseHairpin ");
          for (strand = 0; strand < totalStrands; ++strand)
	      printf(" %d", useHairpin[strand]);
	   printf("\n");
	   }

	 longcount = 0;
	 mincore[sheet] = 10000;
	 maxcore[sheet] = -10;
	 if(has_core) {
           for(strand = 0; strand < betaCount[sheet]; ++strand) {
              i = positionInverse[sheet][strand];
	       if(shpr) printf("sheet %d strand %d i %d coreBeta %d mincore %d maxcore %d\n",
	          sheet, strand, i, coreBeta[i], mincore[sheet], maxcore[sheet]);
	       if(coreBeta[i]) {
	          if(strand < mincore[sheet]) mincore[sheet] = strand;
	          if(strand > maxcore[sheet]) maxcore[sheet] = strand;
	          }
	       }
	    if(0) printf("sheet %d  mincore %d maxcore %d\n",
	          sheet, mincore[sheet], maxcore[sheet]);
	          
// redundent test to skip case if core strands are not consecutive

	    if(maxcore[sheet] - mincore[sheet] + 1 != coreSheetSize[sheet])
	          {
	          printf("bad skipped case should have been already skipped\n");
	          exit(-1);
	          }
	    }

        if(shpr) printf("before shortening\n");
        if(printStruct) printStructure(state->protein);

// For zipping, first set up number, range, and direction of loops to zip
// from core stretch outwards, possibly in both directions.

        if (maxcore[sheet] < 0) {
           if (has_core) {
              printf("has_core is true but maxcore < 0\n");
              exit(-1);
              }
           loops = 1;
           start_strand[0] = 0;
           end_strand[0] = betaCount[sheet] - 1;
           direction[0] = 1;
           placed[positionInverse[sheet][0]] = 1;
           }
        else if (mincore[sheet] == 0) {
	    if (maxcore[sheet] == betaCount[sheet] - 1)
	       loops = 0;
	    else {
              loops = 1;
              start_strand[0] = maxcore[sheet];
              end_strand[0] = betaCount[sheet] - 1;
              direction[0] = 1;
              }
           }
        else if (maxcore[sheet] == betaCount[sheet] - 1) {
           loops = 1;
           start_strand[0] = mincore[sheet];
           end_strand[0] = 0;
           direction[0] = -1;
           }
        else {
           loops = 2;
           start_strand[0] = maxcore[sheet];
           end_strand[0] = betaCount[sheet] - 1;
           direction[0] = 1;
           start_strand[1] = mincore[sheet];
           end_strand[1] = 0;
           direction[1] = -1;
           }

// now shorten strands starting from coil ends inwards

         if(shorten) {
          if(shpr) {
             printf("position ");
             for (strand = 0; strand < betaCount[sheet]; ++strand)
                printf(" %d", position[sheet][strand]);
             printf("\npositionInverse ");
             for (strand = 0; strand < betaCount[sheet]; ++strand)
                printf(" %d", positionInverse[sheet][strand]);
                printf("\n");
             }
          for (lp = 0; lp < loops; ++lp) {  // side of core in sheet
           for(strand =  start_strand[lp];
             strand != end_strand[lp];
             strand += direction[lp]) {    // strand
            strandzip = strand + direction[lp];
            if (direction[lp] > 0)
               strand1 = strand;
            else
               strand1 = strandzip;
           i = positionInverse[sheet][strand];
           if(coreBeta[i]) continue;
           b0 = bestBegin[sheet][strand][ic];
           e0 = bestEnd[sheet][strand][ic];
           if(b0 < betaStart[i])
              printf("bad bestBegin %d betaStart %d\n",
                 b0, betaStart[i]);
           if(e0 > betaStart[i] + betaLength[i] - 1)
              printf("bad bestEnd %d betaEnd %d\n",
                 e0, betaStart[i] + betaLength[i] - 1);
           add = 0;

// allow extra space for diagonal hydrogen bonds on parallel strands

           if (strand > 0)
              if(up[sheet][strand] == up[sheet][strand - 1]) add = 1;
           if (strand < betaCount[sheet] - 1)
              if(up[sheet][strand] == up[sheet][strand + 1]) add = 1;
           if(shpr) printf(
              "i %d ic %d sheet %d strand %d begin %d end %d betaStart %d betaEnd %d add %d\n",
              i,  ic, sheet, strand, b0 - add, e0 + add, betaStart[i],
              betaStart[i] + betaLength[i] - 1, add);
           if (i > 0 && lastCoil[i - 1] == 1)
            for (j = betaStart[i]; j < b0 - add; ++j) {
              ++shortcount;
              if(shorten > 1)
                 for (m = -2; m <= 2; ++m) {
                 if (j + m - subtract >= 0)
                    ECH = pred[j + m - subtract];
                 else
                    ECH = ' ';
                 std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
                      << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
                      << "  " << ECH << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
                      }
              state->protein->changeResidueStructureType(
                 state->protein->pickResidue(j + firstResidueIndex),
                 Protein::SecondaryStructure::COIL);
              if(shorten > 1) printf("changed beginning residue %d to COIL\n",
                 j + firstResidueIndex);
              if(shorten > 1) {
                 for (m = -2; m <= 2; ++m) {
                 if (j + m - subtract >= 0)
                    ECH = pred[j + m - subtract];
                 else
                    ECH = ' ';
                 std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
                      << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
                      << "  " << ECH << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
                      }
                 std::cout << "\n";
                 }
              }
           if (i < betaCount[sheet] - 1 && firstCoil[i] == 1)
            for (j = betaStart[i] + betaLength[i] - 1; j > e0 + add; --j) {
              ++shortcount;
              if(shorten > 1)
                 for (m = -2; m <= 2; ++m) {
                 if (j + m - subtract >= 0)
                    ECH = pred[j + m - subtract];
                 else
                    ECH = ' ';
                 std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
                      << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
                      << "  " << ECH << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
                      }
              state->protein->changeResidueStructureType(
                 state->protein->pickResidue(j + firstResidueIndex),
                 Protein::SecondaryStructure::COIL);
              if(shorten > 1) printf("changed ending residue %d to COIL\n",
                 j + firstResidueIndex);
              if(shorten > 1) {
                 for (m = -2; m <= 2; ++m) {
                 if (j + m - subtract >= 0)
                    ECH = pred[j + m - subtract];
                 else
                    ECH = ' ';
                 std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
                      << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
                      << "  " << ECH << "  "
                      << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
                      }
                 std::cout << "\n";
                 }
              }
            }  // strand
           } // side of core in sheet
          state->proteinRenderer->updateStructureFlags();
          }
        if(shpr) printf("after shortening\n");
        shortened_sheet = sheet;         // in case of early jump to giveUP
        if(printStruct) printStructure(state->protein);

//  Flatten flattening strand, which is really strand i, for each i.
//  This starts with "if(0 && flatten)" because this code has been moved
//  to the beginning of BuildBeta. Instead, we must reinitialize the
//  dihedral angles if there has been shortening.

         if (shorten && flatten) {  //flatten
          for (strand = 0; strand < betaCount[sheet]; ++strand) { //strands
           i = positionInverse[sheet][strand];
           if(!coreBeta[i]) {
             Protein::StructureSelector flatteningStrand = state->protein->pickStructure(betaPiece[i]);
             state->interactor->selectStructure(flatteningStrand);
             state->interactor->clearCoilRegions();
             numResidues = state->interactor->getStructure().getNumResidues();
             if(0) printf("flattening %d residues in strand %d\n", numResidues, i);
             if(numResidues > 2 && state->interactor->isBetaStrand())
               {
               MD::Scalar* phis=new MD::Scalar[numResidues];
               MD::Scalar* psis=new MD::Scalar[numResidues];
               if(optimized_angles == 0 || numResidues < 5)
                  for(j=0;j<numResidues;++j)
                     {
                     phis[j]=Math::rad(flatPhi);
                     psis[j]=Math::rad(flatPsi);
                     }
               else {
                  up1 = up[sheet][position[sheet][i]];
                  if(position[sheet][i] > 0)
                     up0 = up[sheet][position[sheet][i] + below[i]];
                  else
                     up0 = 1 - up1; // favor antiparallel
                  if(position[sheet][i] < betaCount[sheet] - 1)
                     up2 = up[sheet][position[sheet][i] - below[i]];
                  else
                     up2 = 1 - up1; // favor antiparallel
                  par0 = (up0 == up1);
                  par1 = (up1 == up2);
                  environment = par0 + 2*par1;
                  for(j=0;j<numResidues;++j)
                     {
                     phis[j]= optPhi[environment][numResidues][j];
                     psis[j]= optPsi[environment][numResidues][j];
                     if(printhair) printf("%d %f %f\n", j, phis[j], psis[j]);
                     }
                  if(printhair) printf("used optimized angles on strand %d\n", i);
                  }
               undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
               state->interactor->setDihedralAngles(phis,psis);
               delete[] phis;
               delete[] psis;
               undoBuffer.finishInteraction();
               state->proteinRenderer->updateProtein();
               if(state->energyCalculator!=0)
                       state->energyCalculator->updateProtein();
               }
           }
          state->proteinRenderer->updateStructureFlags();
          }  // strands
         } // flatten

        strcpy(partialoutputfilename, protein_name);
        strcat(partialoutputfilename, ".");
        sprintf(digits, "%d", succeeded);
        if(shpr) printf("partialoutputfile %d ", succeeded);
        strcat(partialoutputfilename, digits);
        strcat(partialoutputfilename, ".topology");
        sprintf(digits, "%d",kt);
        strcat(partialoutputfilename, digits);
        strcat(partialoutputfilename, digits);
        strcat(partialoutputfilename, ".sheet");
        if(shpr) printf("kt %d lt %d mt %d\nsh ", kt, lt, mt);
        for (k = 0; k < totalStrands; ++k) {
              sprintf(digits, "%d", sh[k]);
              if(shpr) printf("%d ", sh[k]);
              strcat(partialoutputfilename, digits);
              }

        if(offlineBuildBeta == 0  && interact > 2) {
                 fprintf(stderr, "after partial output file\a\n");
                 printf("type r for return, other character to continue ");
                 if(getchar() == 'r') {
                        state->proteinRenderer->updateStructureFlags();
                    return;
                    }
                 }
        for (lp = 0; lp < loops; ++lp) {  // side of core in sheet
	  if(shpr) printf("beginning side %d of core sheet\n", lp);
	  odd = od%2;
	  od = od/2;
	  if(oddprint) printf("mt %d odd %d od %d\n", mt, odd, od);
         for(strand =  start_strand[lp];
	      strand != end_strand[lp];
	      strand += direction[lp]) {    // strand loop
           strandzip = strand + direction[lp];
           if (direction[lp] > 0)
              strand1 = strand;
           else
              strand1 = strandzip;

// strandzip is the adjacent strand that moves during the zipping.
// strand1 is the lower in-sheet index of the two strands being zipped, and
// must be used as an index for the arrays of alignments s tested, since
// in a one-strand core, the fixed strand may be zipped to on both sides.

           i = positionInverse[sheet][strand];
           j = positionInverse[sheet][strandzip];
	    if (i < j)
	       ii = i;
	    else
	       ii = j;
	    if(distpr) printf("strand %d coreBeta[%d] = %d  coreBeta[%d] = %d\n",
	       strand, i, coreBeta[i], j, coreBeta[j]);
	    if(coreBeta[i] && coreBeta[j]) {
	       if(distpr) printf("position %d strand %d in core so zipping skipped\n",
	          j, strand);
	       continue;
	       }
           len0 = betaLength[i];
           len1 = betaLength[j];
	    s = bestTotalStart[sheet][strand1][ic];
	    if (oddprint) printf("oddprint s %d strand1 %d ic %d\n", s, strand1, ic);
	    if( s > 0 )
	       k0 = 0;
	    else 
	       k0 = -s;

	    if(len1 - s < len0)
	       k1 = len1 - s - 1;
	    else
	       k1 = len0 - 1;
	    k = (k0 + k1)/2;

     if(coilPrint > 1) {  // for printing only
        int oldb1, olde1, b2, e2;

//  At this point k1 is the actual last residue, not the upper limit of the loop.
//  Compute possible shortening of beta strands in favor of lengthened coils.
	 
	 oldb1 = b1;
	 olde1 = e1;
	 if(up[sheet][strand]) {
	    b0 = betaStart[i] + k0;
	    e0 = betaStart[i] + k1;
	    }
	 else {
	    b0 = betaStart[i] + betaLength[i] - 1 - k1;
	    e0 = betaStart[i] + betaLength[i] - 1 - k0;
	    }
	 if(up[sheet][strandzip]) {
	    b1 = betaStart[j] + k0 + s;
	    e1 = betaStart[j] + k1 + s;
	    }
	 else {
	    b1 = betaStart[j] + betaLength[j] - 1 - k1 - s;
	    e1 = betaStart[j] + betaLength[j] - 1 - k0 - s;
	    }
	 if(extrapr) printf("extra k0 %d k1 %d s %d b0 %d e0 %d b1 %d e1 %d\n",
	    k0, k1, s, b0, e0, b1, e1);
	 if(strand != start_strand[lp]) {
	    b2 = b0;
	    e2 = e0;
	    if(oldb1 < b0) b2 = oldb1;
	    if(olde1 > e0) e2 = olde1;
	    if(extrapr) printf("extra strand %d i %d begin %d %d %d end %d %d %d\n",
	       strand, i, b0, oldb1, b2, e0, olde1, e2);
	    }
        }  // for printing only

// both p0 and p1 count from the bottom of the strand as drawn in the sheet

           if(useHairpin[strand1]) {

// Adjust p0 and p1 using presumed zip at residue 4 of a 7 residue strand pair,
// measuring from aligned high end of the first of the two strands in chain sequence,
// and low end of the next strand.

	       if(oddprint) printf("Adjusting p0 and p1 using presumed zip at residue 4 of a 7 residue strand pair.\n");
              if (i < j) {
	          p0 = betaStart[i] + betaLength[i] - 4;
	          p1 = betaStart[j] + 3;
	          }
	       else {
	          p0 = betaStart[i] + 3;
	          p1 = betaStart[j] + betaLength[j] - 4;
	          }
	       }
	    else {
	       if(up[sheet][strand])
	          p0 = betaStart[i] + k;
	       else
	          p0 = betaStart[i] + betaLength[i] - 1 - k;
	       if(up[sheet][strandzip])
	          p1 = betaStart[j] + k + s;
	       else
	          p1 = betaStart[j] + betaLength[j] - 1 - (k + s);
	       }
	    p0 += firstResidueIndex;
	    p1 += firstResidueIndex;
	    if(oddprint) printf("after adjustment by firstResidueIndex %d p0 = %d and p1 = %d\n"
	       , firstResidueIndex, p0, p1);

// Skip case if adjacent to core region and free side of core is not
// the one being hydrogen bonded to, or if both edges are free for a one-strand
// core sheet, only do first odd case, and recompute odd later.

	    if(0 && coreBeta[j] && !coreBeta[i] && core_edge[j]
	      [(p1 + odd + (up[sheet][strand] ==
	      up[sheet][strandzip])) %2] >= 0)
	       {
	       printf("this case should not happen if moving outward from core edges\n");
	       exit(-1);
	       goto giveUp;
	       }

	    if(oddprint)printf(
	       "coreBeta[%d] %d coreBeta[%d] %d p0 %d odd %d twist %d core_edge %d lp %d \n",
	       i, coreBeta[i], j, coreBeta[j], p0, odd, twist[p0], 
	       core_edge[i][(p0 + twist[p0] + odd)%2], lp);
 	    if ( (coreBeta[i] && !coreBeta[j] &&
	         ( core_edge[i][(p0 + /* twist[p0] + */ odd)%2] >= 0) ) ||
	       (core_edge[i][0] < 0 && core_edge[i][1] < 0 && loops == 2 && odd == 1) ) {
	          if (early_skip_print) printf("skippedCase4 sheet %d\n", sheet);
	          ++skippedCase4[sheet];
	          goto giveUp;
	          }

// Compute initial odd for single strand core case.

	    if (core_edge[i][0] < 0 && core_edge[i][1] < 0 && loops == 2 && 
	       strand == start_strand[lp]) {
	         odd = (((p0 + twist[p0]) % 2) + lp) % 2;
		 if(twistprint)
		    printf("single strand core case p0 %d lp %d odd %d\n", p0, lp, odd);
		 }

	    else if (0 && strand == start_strand[lp]) {

// Adjust initial odd specified from od to account for twist

              odd = (odd + twist[p0]) % 2;
	       }

	    else if (strand != start_strand[lp]) {

// Propagate odd along sheet.
// Odd is 0 if  hydrogen bond sites on strand 0 at p0 point to the right.

// If difference between zipping residues is odd, new odd must be switched.
// If previous zipping was antiparallel, new odd must be switched.
// If non-moving strand is twisted, new odd must be switched.

	       if(oddprint) printf("adjusting odd: initially %d p0 %d savep1 %d up %d %d",
	          odd, p0, savep1, up[sheet][strand - direction[lp]], up[sheet][strand]);
	       if( (p0 + savep1)%2) odd = 1 - odd;
	       if(up[sheet][strand - direction[lp]] != up[sheet][strand])
	          odd = 1 - odd;
	       if ( twist[savep1] != twist[p0] ) {
	          odd = 1 - odd;
		  if (twistprint)
		     printf("odd switched because of twist in strand %d residue %d\n", j, p1);
		  }
	       if(oddprint) printf(" finally odd is %d\n", odd);
	       }
	    savep1 = p1;
	    Protein::StructureSelector movingStrand;

// See whether saves zip angles from succesful test zip should be used.

	    sz = -1;
	    if(printhair)
	       printf("looking for saved zip values for strand strand1 %d odd %d saved_zips %d s %d\n"
	       , strand1, odd, saved_zips[strand1][odd], s);
	    for(l = 0; l < saved_zips[strand1][odd]; ++l)
	       if(zip_s[strand1][odd][l] == s)
	          sz = l;
	    if(printhair && sz >= 0)
	       printf("using saved zip on strand %d odd %d sz %d s %d\n",
	       strand1, odd, sz, s);

	    no_moving_strand = 0;
	    if (useHairpin[strand1] || sz >= 0) {  

//  Determine piece and moving strand

	      e1 = -1;
	      if (i == j+1)
	         for (m = 0; m < j; ++m) {
		    if(printhair) printf("for i = j+1 hair: placed[%d] = %d\n", m, placed[m]);
		    if(placed[m]) {
		       e1 = betaStart[m];
		       piece = m;
		       }
		    }
	      if (i == j-1) 
	         for (m = totalStrands - 1; m > j; --m) {
		    if(printhair) printf("for i = j-1 hair: placed[%d] = %d\n", m, placed[m]);
		    if(placed[m]) {
		       e1 = betaStart[m];
		       piece = m;
		       }
		    }
	      if (e1 >= 0) 
	         movingStrand = state->protein->pickStructure(betaPiece[piece]);
	      else {
	         printf("e1 < 0 when detemining moving strand for hairpin case\n");
		 no_moving_strand = 1;
		 // goto giveUp; // It is OK if there are no anchors to move.
		 }
	      }
	    else
	      movingStrand = state->protein->pickStructure(betaPiece[j]);
	    if(coilPrint) {
	       printf("placed ");
	       for(l = 0; l < totalStrands; ++l)
	          printf("%d ", placed[l]);
	       }
	    if (no_moving_strand == 0) {
	       state->interactor->selectStructure(movingStrand);
              state->interactor->clearCoilRegions();
	       if(ziprint) {
	         printf("attempting zip between strand %d residue %d and strand %d residue %d s %d odd %d\n",
	             i, p0, j, p1, s, odd);
	         printf("twist[%d] = %d\n", p0, twist[p0]);
	         }

// Decide which coils should be flexible on this move.
	    
	       if(coilPrint) printf("placing strand %d coilpieces: left ", j);
              l = j - 1;
	       found = 0;
	       for (m = 0; m < j; ++m) 
	          found += placed[m];

// Only toggle coils if there is an already placed strand before this one,
// and angles are not to be specified by precomputed hairpin data.

	       if(found > 0 && (!(useHairpin[strand1] || sz >= 0) || i != j-1))
	         while(1) {
	          if( l < 0 || placed[l + 1]) {
		     if (coilPrint) printf(" break %d placed %d \n",
		        l, placed[l + 1]);
	             break;
		     }
                 for(k = 0; k < nCoilPieces[l]; ++k)
		    if(!coreCoil[l][k]) {
	             state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][k]));
	             if(coilPrint) printf(" %d", coilPiece[l][k]);
	             }
	            else if(coilPrint) printf(" %d", -coilPiece[l][k]);
	          --l;
	          }
	       l = j;
	       if(coilPrint) printf("  right ");
	       // state->interactor->printCoils(5);

	       found = 0;
	       for (m = totalStrands - 1; m > j; --m) 
	          found += placed[m];
	       if(found > 0 && (!(useHairpin[strand1] || sz >= 0) || i != j + 1))
	         while(1) {
	          if(l == totalStrands - 1 || placed[l]) {
		     if (coilPrint) printf(" break %d placed %d \n",
		        l, placed[l + 1]);
	             break;
		     }
                 for(k = 0; k < nCoilPieces[l]; ++k) 
		    if(!coreCoil[l][k]) {
	             state->interactor->toggleCoil(state->protein->pickStructure(coilPiece[l][k]));
	             if(coilPrint) printf(" %d", coilPiece[l][k]);
	             }
	            else if(coilPrint) printf(" %d", -coilPiece[l][k]);
	          ++l;
	          }
	       if(0 || coilPrint) printf("\n  p0 %d p1 %d  k %d s %d \n", p0, p1, k, s);
	       // state->interactor->printCoils(5);
	       fflush(stdout);
	       }

	    if(offlineBuildBeta == 0 && interact > 1 && (0 && gaveup == 12) ) {
		printf("before moving strand %d\n", j);
               printf("type r for very early return, any other character to continue \a");
               if(getchar() == 'r') {
		    state->proteinRenderer->updateStructureFlags();
	           return;
	           }
	        }
	    if (useHairpin[strand1] || sz >= 0) {  // do hairpin
	       if (e1 >= 0) { // there is an anchor; it is OK if there is not

// fix location of three points on the moving anchor, so its position can be restored

	          residue1 = state->protein->pickResidue(e1 + firstResidueIndex);
	          carb1 = residue1->getCarboxyl().getMajorAtom()->getPosition();
	          residue2 = state->protein->pickResidue(e1 + 1 + firstResidueIndex);
	          carb2 = residue2->getCarboxyl().getMajorAtom()->getPosition();
	          residue3 = state->protein->pickResidue(e1 + 2 + firstResidueIndex);
	          carb3 = residue3->getCarboxyl().getMajorAtom()->getPosition();
	          }
              if (flatfrac < .20) 
	          fl = 0;
              if (flatfrac < .55) 
	          fl = 1;
	       else if (flatfrac < .85)
	          fl = 2;
	       else
	          fl = 3;
	       if (i < j) {
	          e0 = betaStart[i] + betaLength[i] + firstResidueIndex;
		  change_direction = 1;
		  }
	       else {
	          e0 = betaStart[j] + betaLength[j] + firstResidueIndex;
		  change_direction = -1;
		  }
	       state->protein->getDihedralAngles(e0, 4, dphi, dpsi);
	       if (printhair) printf("hair odd %d flatfrac %f fl %d\n", odd, flatfrac, fl);
	       if (printhair) printf("  up[%d] = %d; up[%d] = %d\n",
	          strand1, up[sheet][strand1], piece, up[sheet][piece]);
	       if (printhair > 1) printf("old dphi %f dpsi %f\n", dphi[0], dpsi[0]);
	       for (m = 0; m < 4; ++m) {
	          if(useHairpin[strand1]) {

// double hairpinAngles[2][4][4][2] = [alt][flatfrac][turn residue][phi/psi]

	             dphi[m] = PI*hairpinAngles[odd][fl][m][0]/180. - dphi[m];
	             dpsi[m] = PI*hairpinAngles[odd][fl][m][1]/180. - dpsi[m];
		     }
		  else {
		     dphi[m] = zip_phi[strand1][odd][sz][m] - dphi[m];
		     dpsi[m] = zip_psi[strand1][odd][sz][m] - dpsi[m];
	             if (printhair > 1) printf(
		        "strand1 %d odd %d sz %d m %d saved dphi %f dpsi %f\n",
			strand1, odd, sz, m,
	                zip_phi[strand1][odd][sz][m], zip_psi[strand1][odd][sz][m]);
		     }
		  }
	       if (printhair > 1) printf("temp dphi %f dpsi %f\n", dphi[0], dpsi[0]);
	       // state->interactor->printCoils(1);
              undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
	       state->protein->changeDihedralAngles(e0, 4, dphi, dpsi, change_direction);
              undoBuffer.finishInteraction();
	       if (printhair > 1) state->protein->getDihedralAngles(e0, 4, dphi, dpsi);
	       if (printhair > 1) printf("new dphi %f dpsi %f\n", dphi[0], dpsi[0]);
	       state->proteinRenderer->updateProtein();
	       if(!offlineBuildBeta) updateProteinNow();
	       // state->interactor->printCoils(2);

	       if (e1 >= 0) {

//   Put back anchor where it belongs. First get three displaced points.

	          ncarb1 = residue1->getCarboxyl().getMajorAtom()->getPosition();
	          ncarb2 = residue2->getCarboxyl().getMajorAtom()->getPosition();
	          ncarb3 = residue3->getCarboxyl().getMajorAtom()->getPosition();

//   Rotate to align vectors between first two carboxyls.

	          Vector axis1 = normalize(Geometry::cross(carb2 - carb1,
	             ncarb2 - ncarb1));
	          dt = dot(carb2 - carb1, ncarb2 - ncarb1) /
	             sqrt(dot(carb2 - carb1, carb2 - carb1) *
	             dot(ncarb2 - ncarb1, ncarb2 - ncarb1));
	          angle1 = acos(dt);
	          Transformation tempTransformation=Transformation::identity;
	          Transformation trans1 = Transformation::rotate(
	          Transformation::Rotation::rotateAxis(axis1,-angle1));
   	          tempTransformation.leftMultiply(trans1);
	          Point lncarboxyl1 = tempTransformation.transform(ncarb1);
	          Point lncarboxyl2 = tempTransformation.transform(ncarb2);
	          Point lncarboxyl3 = tempTransformation.transform(ncarb3);

//   Find component of C3 - C1 perpendicular to C2 - C1.

	          Vector axis = normalize(carb2 - carb1);
	          dt = dot(carb3 - carb1, axis);
	          double newdt = dot(lncarboxyl3 - lncarboxyl1, axis);
	          Vector CM, newCM;
	          for (m = 0; m < 3; ++m) {
	             CM[m] = carb3[m] - carb1[m] - dt*axis[m];
	             newCM[m] = lncarboxyl3[m] - lncarboxyl1[m] - newdt*axis[m];
	             }
	          dt = dot(newCM, CM)/sqrt(dot(CM, CM)*dot(newCM, newCM));

//   Rotate to align C3's.

	          angle2 = acos(dt);
	          if(dot(Geometry::cross(newCM, CM), axis) < 0)
	             angle2 = - angle2;
	          if(fixp) printf("angle1 %f angle2 %f\n", angle1*180./PI, angle2*180./PI);
	          Transformation trans2 = Transformation::rotate(
	             Transformation::Rotation::rotateAxis(axis, angle2));
 	          tempTransformation.leftMultiply(trans2);
	          Point lnwcarboxyl1 = tempTransformation.transform(ncarb1);
	          if(fixp) printf("lnwcarboxyl1 %f %f %f\n",
	             lnwcarboxyl1[0], lnwcarboxyl1[1], lnwcarboxyl1[2]);
	          Vector disp = carb1 - lnwcarboxyl1;
	          Transformation trans3=Transformation::translate(disp);
	          tempTransformation.leftMultiply(trans3);
	          applyTransformation(tempTransformation);
                 state->proteinRenderer->updateProtein();
	          if(!offlineBuildBeta) updateProteinNow();

/*
//   Check that desired repositioning was done

		  printf("original positions\n");
		  printf ("carb1 %g %g %g\n", carb1[0], carb1[1], carb1[2]);
		  printf ("carb2 %g %g %g\n", carb2[0], carb2[1], carb2[2]);
		  printf ("carb3 %g %g %g\n", carb3[0], carb3[1], carb3[2]);
		  printf("\n");

		  printf ("positions after just hairpin substitution\n");
		  printf ("ncarb1 %g %g %g\n", ncarb1[0], ncarb1[1], ncarb1[2]);
		  printf ("ncarb2 %g %g %g\n", ncarb2[0], ncarb2[1], ncarb2[2]);
		  printf ("ncarb3 %g %g %g\n", ncarb3[0], ncarb3[1], ncarb3[2]);
		  printf("\n");

		  printf ("positions after rotation to align vectors between first two carboxyls\n");
		  printf ("lncarb1 %g %g %g\n", lncarboxyl1[0], lncarboxyl1[1], lncarboxyl1[2]);
		  printf ("lncarb2 %g %g %g\n", lncarboxyl2[0], lncarboxyl2[1], lncarboxyl2[2]);
		  printf ("lncarb3 %g %g %g\n", lncarboxyl3[0], lncarboxyl3[1], lncarboxyl3[2]);
		  printf("\n");


		  printf("Positions produces by goal transformation matrix\n");
	          lncarboxyl1 = tempTransformation.transform(ncarb1);
	          lncarboxyl2 = tempTransformation.transform(ncarb2);
	          lncarboxyl3 = tempTransformation.transform(ncarb3);
		  printf ("lncarb1 %g %g %g\n", lncarboxyl1[0], lncarboxyl1[1], lncarboxyl1[2]);
		  printf ("lncarb2 %g %g %g\n", lncarboxyl2[0], lncarboxyl2[1], lncarboxyl2[2]);
		  printf ("lncarb3 %g %g %g\n", lncarboxyl3[0], lncarboxyl3[1], lncarboxyl3[2]);
		  printf("\n");

		  printf ("final positions after IK re-alignment\n");
	          ncarb1 = residue1->getCarboxyl().getMajorAtom()->getPosition();
	          ncarb2 = residue2->getCarboxyl().getMajorAtom()->getPosition();
	          ncarb3 = residue3->getCarboxyl().getMajorAtom()->getPosition();
		  printf ("ncarb1 %g %g %g\n", ncarb1[0], ncarb1[1], ncarb1[2]);
		  printf ("ncarb2 %g %g %g\n", ncarb2[0], ncarb2[1], ncarb2[2]);
		  printf ("ncarb3 %g %g %g\n", ncarb3[0], ncarb3[1], ncarb3[2]);
		  printf("\n");
*/

                 printf("IK residual for hairpin  %g\n", lastIKResidual);
                 } 
	       else
	          lastIKResidual = 0.;  // no anchor motion necessary
	       goto zipped;
	       }  // do hairpin
	   else {   

// start zipping

	    if(offlineBuildBeta == 0  && interact > 2) {
	          fprintf(stderr, "at start zipping\a\n");
                 printf("type r for return, other character to continue ");
                 if(getchar() == 'r') {
		         state->proteinRenderer->updateStructureFlags();
	             return;
	             }
		  }
	    lastIKResidual = 2.;
	    if(up[sheet][strand] == up[sheet][strandzip]) {
	      if((odd + twist[p0]) % 2 == 0) {
		if(oddprint) printf("altZipParallel  ");
	        r = altZipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[centers], center[centers]);
		if(r != 0) goto zipped;
		if(beyond || (p0 - 1 - firstResidueIndex >= betaStart[i] &&
		   p1 - 1 - firstResidueIndex >= betaStart[j]) ) {
		   if( (twist[p0] + twist[p0-1] + twist[p1] + twist[p1-1]) % 2 == 0) 
		      r=zipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[centers], center[centers]);
		   else
		      r = 0;
		   if(r != 0) goto zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) &&
		      (twist[p0] + twist[p0+1] + twist[p1] + twist[p1+1]) % 2 == 0) {
		      r=zipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[centers], center[centers]);
		      if (r != 0) goto zipped;
		      }
		   }
		goto quitProline;
		}
	      else {
		if(oddprint) printf("ZipParallel  ");
	        r = zipParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[centers], center[centers]);
		if(r != 0) goto zipped;
		if(beyond || (p0 - 1 - firstResidueIndex >= betaStart[i] &&
		   p1 - 1 - firstResidueIndex >= betaStart[j]) ) {
		   if( (twist[p0] + twist[p0-1] + twist[p1] + twist[p1-1]) % 2 == 0) 
		      r=altZipParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0-1), plane[centers], center[centers]);
		   else
		      r = 0;
		   if(r != 0) goto zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) &&
		      (twist[p0] + twist[p0+1] + twist[p1] + twist[p1+1]) % 2 == 0) {
		      r=altZipParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0+1), plane[centers], center[centers]);
		      if(r != 0) goto zipped;
		      }
		   }
		goto quitProline;
		}
	      }
	    else {

// Figure 8A of Zhu and Braun shows anti-parallel strands matched with one flipped.

	      if((odd + twist[p0]) % 2 == 0) {
		if(oddprint) printf("ZipAntiParallel  ");
	        r = zipAntiParallel(state->protein->pickResidue(p1), state->protein->pickResidue(p0), plane[centers], center[centers]);
		if(r != 0) goto zipped;
		if(beyond || (p0-1-firstResidueIndex >= betaStart[i] &&
		   p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) ) {
		   if ((twist[p0] + twist[p0-1] + twist[p1] + twist[p1+1]) % 2 == 0)
		      r = altZipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[centers], center[centers]);
		   else
		      r = 0;
		   if(r != 0) goto zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1-1-firstResidueIndex >= betaStart[j]) &&
		      (twist[p0] + twist[p0+1] + twist[p1] + twist[p1-1]) % 2 == 0) {
		      r = altZipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[centers], center[centers]);
		      if(r != 0) goto zipped;
		      }
		   }
		goto quitProline;
		}
	      else {
		if(oddprint) printf("altZipAntiParallel  ");
	        r = altZipAntiParallel(state->protein->pickResidue(p1),state->protein->pickResidue(p0), plane[centers], center[centers]);
		if(r != 0) goto zipped;
		if(beyond || (p0-1-firstResidueIndex >= betaStart[i] &&
		   p1+1-firstResidueIndex < betaStart[j]+betaLength[j]) ) {
		   if ((twist[p0] + twist[p0-1] + twist[p1] + twist[p1+1]) % 2 == 0)
		      r = zipAntiParallel(state->protein->pickResidue(p1+1), state->protein->pickResidue(p0-1), plane[centers], center[centers]);
		   else
		      r = 0;
		   if(r != 0) goto zipped;
		   if(beyond || (p0+1-firstResidueIndex < betaStart[i]+betaLength[i] &&
		      p1-1-firstResidueIndex >= betaStart[j]) &&
		      (twist[p0] + twist[p0+1] + twist[p1] + twist[p1-1]) % 2 == 0) {
		      r = zipAntiParallel(state->protein->pickResidue(p1-1), state->protein->pickResidue(p0+1), plane[centers], center[centers]);
		      if(r != 0) goto zipped;
		      }
		   }
		goto quitProline;
		}
	      }
	     }
quitProline:
	    if(otherprint) printf("Zip failed because of too many prolines\n");
	    ++zipProline;
	    goto giveUp;
zipped:
           if(offlineBuildBeta == 0  && interact > 1) {
	          printf("at zipped, after zipping or hairpin\n");
                 printf("type r for return, other character to continue ");
                 if(getchar() == 'r') {
		         state->proteinRenderer->updateStructureFlags();
	             return;
	             }
		  }
	    if (!useHairpin[strand1] && sz < 0 ){
	       if(printhair)
	          printf("centers %d center of zipping quadrilteral %f %f %f\n",
	            centers, center[centers][0], center[centers][1], center[centers][2]);
	       if(up[sheet][strand]) 
	          for(i = 0; i < 3; ++i) {
	              plane[centers][i]  = - plane[centers][i];
	              bbb0[centers][i] = bb0[i];
	              bbb1[centers][i] = bb1[i];
		      }
	       ++centers;
	       }
           if(0) printf("bestTotalStart ");
           if(0)
	     for(tstrand = 0; tstrand < betaCount[sheet] - 1; ++tstrand) {
              printf("%d ", bestTotalStart[sheet][tstrand][ic]);
              }
           printf("IK error %g  for strand %d\n",lastIKResidual, strand);
	    if(ziprint > 1)
	      printf("zip between strand %d residue %d and strand %d residue %d s %d\n",
	          i, p0, j, p1, s);
	    placed[j] = 1;
	    state->interactor->selectStructure(MD::Protein::StructureSelector());

           if(lastIKResidual >= zip_threshold) {
              ++gaveup;
              printf("IK did not converge; residual %g shortened %d gaveup %d\n", 
	          lastIKResidual, shortcount, gaveup);
	       if(offlineBuildBeta == 0  && interact > 0) {
	          fprintf(stderr, "before undoing shortening\a\n");
                 printf("type r for return, other character to continue ");
                 if(getchar() == 'r') {
		         state->proteinRenderer->updateStructureFlags();
	             return;
	             }
		  }
              goto giveUp;
              } 

	    ++zipcount;
	    if (zipOutPdb) {
	       strcpy(outputfilename, partialoutputfilename);
	       strcat(outputfilename, ".zip");
	       sprintf(digits, "%d",zipcount);
	       strcat(outputfilename, digits);
	       strcat(outputfilename, ".strand");
	       sprintf(digits, "%d",strand);
	       strcat(outputfilename, digits);
	       strcat(outputfilename, ".pdb");
              writePdbFile(*state->protein, outputfilename,writeStructure);
	       printf("writing partial zip file %s\n", outputfilename);
	       }
	    if (twist[p0]) {
	       if(oddprint) printf("switching odd at end of zipping because of twist[p0]\n");
	       odd = 1 - odd;
	       }
           }    // strand loop
	   }  // side of core in sheet

	 good = 0;
	 if (betaCount[sheet] > 1)
	    for( ibb = -1; ibb < betaCount[sheet]; ++ibb) 
	      if (ibb < 0) {
	        if (sh[0] == sheet && nCoilPiecesFirst > 1) good = 1;
		}
	      else {
		ib = positionInverse[sheet][ibb];
	        if( nCoilPieces[ib] > 1 ) good = 1;
		}

/* Now adjust any alpha helices between beta strands so that they are on the
  correct side of the sheet, rather than intersecting it. In the case of an
  alpha helix between (in sequence order) two parallel beta strands, the 
  correct side is one that makes a right hand (screw) turn, as in figure 2 of
  Jane Richardson, "Handedness of crossover connections in beta sheets", PNAS
  Vol. 73, No. 8, August 1976, pp. 2619 - 2623. This side is defined according
  to the up[] direction of the strand before the helix, and the placement (to the
  left or right of this strand) of the strand after the helix, so it makes sense
  even if these two strands are antiparallel.                                   */

	 if(move_helices && good)  { // move helices
	 if(write_helices && !opened_helices) {
	    strcpy(outputfilename, protein_name);
	    strcat(outputfilename, ".");
	    sprintf(digits, "%d", succeeded + 1);
	    strcat(outputfilename, digits);
	    strcat(outputfilename, ".helices");
	    fp = fopen(outputfilename, "w");
	    opened_helices = 1;
	    }
	 for( ibb = -1; ibb < betaCount[sheet]; ++ibb) {  // ibb
	      if (ibb < 0) {
	        if (sh[0] == sheet && nCoilPiecesFirst > 1) {
		   ib = 0;
		   ibq = position[sheet][sheetPosition[0]];
		   }
		else
		   continue;
		}
	     else {
	        ib = positionInverse[sheet][ibb];
		ibq = ibb;
		}
/*
In this case, sh[k] says which beta sheet contains strand k,
sheetPosition[k] says what initial position it has in that sheet,
sheetPositionInverse[sheet][i] = k means sheetPosition[k] = i and sh[k] 
= sheet. These initial positions are modified by permutations, so that
position[sh[k]][sheetPosition[k]] describes its sequential position in the
sheet after a permutation. Then  k = positionInverse[sheet][i] gives the
strand index k so that 

position[sh[k]][sheetPosition[k]] = i.
*/

// Find another strand in the same sheet, preferably the next strand in sequence.

	  if (ib+1 < totalStrands && sh[ib+1] == sheet)
	     ibp = position[sh[ib+1]][sheetPosition[ib+1]];
	  else {
            if(ibq < betaCount[sheet] - 1)
	        ibp = betaCount[sheet] - 1;
	     else
	        ibp = ibq - 1;
	     }
	  ip = positionInverse[sheet][ibp];
	  iq = positionInverse[sheet][ibq];
	  if(0) printf("Indices for base strands for moving helices: ib %d ibq %d ip %d ibp %d\n",
	     ib, ibq, ip, ibp);

	  if( ibb < 0 || nCoilPieces[ib] > 1 ) {  // move set of helices
	   if(save_pre_move_helices) {
           iat = 0;
           for(Protein::ConstAtomIterator
	         aIt=state->protein->atomsBegin();aIt!=state->protein->atomsEnd();++aIt)
              pre_move_helices_coords[iat++] = aIt->getPosition();
	    }

/* Compute plane to move the helices away from, using averages of the plane
  and center data returned by the zipping routines.  */

	   if(old_average_plane) {
	    for(j = 0; j < 3; ++j) {
	       averagePlane[j] = 0.;
	       averageCenter[j] = 0.;
	       }
	    for (i = 0; i < centers; ++i) 
	       for(j = 0; j < 3; ++j) {
	          averagePlane[j] -= plane[i][j];  // this flips all planes
	          averageCenter[j] += center[i][j];
		  }
	    den = 0.;
	    for (j = 0; j < 3; ++j)
	       den += averagePlane[j]*averagePlane[j];
	    den = sqrt(den);
	    for (j = 0; j < 3; ++j) {
	       averagePlane[j] /= den;
	       averageCenter[j] /= centers;
	       }
	    Vector Vplane;
	    if(!make_parallel && write_helices)
	     for (i = 0; i < centers; ++i) {
	       for (j = 0; j < 3; ++j) 
	          Vplane[j] = plane[i][j];
	       Vector axis1 = Geometry::normalize( Geometry::cross(Vplane, DD) );
	       Vector axis2 = Geometry::normalize( Geometry::cross(Vplane, axis1) );

	       if(1) {
	         fprintf(fp, "%f %f %f\n", center[i][0], center[i][1], center[i][2]);
	         fprintf(fp, "%f %f %f\n", Vplane[0], Vplane[1], Vplane[2]);
	         fprintf(fp, "%f %f %f\n", axis1[0], axis1[1], axis1[2]);
	         fprintf(fp, "%f %f %f\n", axis2[0], axis2[1], axis2[2]);
	         fprintf(fp, "\n");
	         fprintf(fp, "%f %f %f\n", bbb0[i][0], bbb0[i][1], bbb0[i][2]);
	         fprintf(fp, "%f %f %f\n", bbb1[i][0], bbb1[i][1], bbb1[i][2]);
	         fprintf(fp, "\n");
	         }
	      }
	    }

// Otherwise make averageCenter the average of the two strand endpoints that are connected
// by this stretch of coils and helices. (See if "(!old_average_plane) " below.)
	       
	    if (coreBeta[iq]) {
	       residue0 = state->protein->pickResidue(betaStart[iq] + firstResidueIndex);
	       residue2 = state->protein->pickResidue(betaStart[iq] + betaLength[iq] - 1 + firstResidueIndex);
	       }
	    else {
	       residue0 = state->protein->pickResidue(bestEnd[sheet][ibq][ic] + firstResidueIndex);
	       residue2 = state->protein->pickResidue(bestBegin[sheet][ibq][ic] + firstResidueIndex);
	       }
	    if (coreBeta[ip]) {
	       residue1 = state->protein->pickResidue(betaStart[ip] + firstResidueIndex);
	       residue3 = state->protein->pickResidue(betaStart[ip] + betaLength[ip] - 1 + firstResidueIndex);
	       }
	    else {
	       residue1 = state->protein->pickResidue(bestBegin[sheet][ibp][ic] + firstResidueIndex);
	       residue3 = state->protein->pickResidue(bestEnd[sheet][ibp][ic] + firstResidueIndex);
	       }
	    carboxyl0 = residue0->getCarboxyl();
	    carboxyl1 = residue1->getCarboxyl();
	    MD::Protein::Dipole carboxyl2 = residue2->getCarboxyl();
	    MD::Protein::Dipole carboxyl3 = residue3->getCarboxyl();
	    Point C0 = carboxyl0.getMajorAtom()->getPosition();
	    Point C1 = carboxyl1.getMajorAtom()->getPosition();
	    Point C2 = carboxyl2.getMajorAtom()->getPosition();
	    Point C3 = carboxyl3.getMajorAtom()->getPosition();
	    Vector D1, D2;
	    if(up[sheet][ibq] == up[sheet][ibp]) {
	       D1 = C1 - C0;
	       D2 = C3 - C2;
	       }
	    else {
	       D1 = C2 - C1;
	       D2 = C3 - C0;
	       }
	    // printf("C0 %f %f %f\n", C0[0], C0[1], C0[2]);
	    // printf("C1 %f %f %f\n", C1[0], C1[1], C1[2]);
	    // printf("C2 %f %f %f\n", C2[0], C2[1], C2[2]);
	    // printf("C3 %f %f %f\n", C3[0], C3[1], C3[2]);
	    // printf("D1 %f %f %f\n", D1[0], D1[1], D1[2]);
	    // printf("D2 %f %f %f\n", D2[0], D2[1], D2[2]);
	    if (!old_average_plane) {
	       averageCenter = Geometry::mid(C0, C1);
	       averagePlane = Geometry::normalize( Geometry::cross(D1, D2));
	       }
	    Vector axis1 = Geometry::normalize( Geometry::cross(averagePlane, D1) );
	    Vector axis2 = Geometry::normalize( Geometry::cross(averagePlane, axis1) );
	    if (helixpr) {
	       Vector Ea1 = Geometry::cross(averagePlane, D1);
	       Vector Ea2 = Geometry::cross(averagePlane, axis1);
	       printf("C0 %f %f %f\n", C0[0], C0[1], C0[2]);
	       printf("C1 %f %f %f\n", C1[0], C1[1], C1[2]);
	       printf("C2 %f %f %f\n", C2[0], C2[1], C2[2]);
	       printf("D1 %f %f %f\n", D1[0], D1[1], D1[2]);
	       printf("Ea1 %f %f %f\n", Ea1[0], Ea1[1], Ea1[2]);
	       printf("Ea2 %f %f %f\n", Ea2[0], Ea2[1], Ea2[2]);
	       printf("center %f %f %f\n",averageCenter[0],averageCenter[1],averageCenter[2]);
	       printf("plane %f %f %f\n", averagePlane[0], averagePlane[1], averagePlane[2]);
	       }

	    if (ibb < 0)
	       alphaStop = nAlphaPiecesFirst;
	    else
	       alphaStop = nAlphaPieces[ib];
	    int ndo = 0;
	    for (np = 0; np < alphaStop; ++np) { // np
	      if (ibb < 0)
	         thisAlpha = alphaPieceFirst[np];
	      else
	         thisAlpha = alphaPiece[ib][np];
	      if(coreAlpha[thisAlpha]) continue;

//  Do not attempt to move helices that are directly adjacent to beta strands.
//  This is removed by "if(0 && ..." below, but if added back in, fix use of ib
//  to deal with the case of the First helices. Yes, fixed; there are now
//  new arrays to deal with this special case.

	      if(0 && np == 0 && firstCoil[ib] != 1) {
		  printf("Did not attempt to move first helix for strand %d.\n",
		     ib);
	          continue;
		  }
	      if(0 && np == nAlphaPieces[ib] - 1 && lastCoil[ib] != 1) {
		     printf("Did not attempt to move last helix for strand %d.\n",
		        ib);
		     continue;
		     }
	      if(0) printf("moving alphaPiece[%d][%d]\n", ib, np);
	      Protein::StructureSelector movingStrand = state->protein->pickStructure(thisAlpha);
	      if(0) printf("alphaPiece[%d][%d] = %d\n", ib, np, thisAlpha);
	      state->interactor->selectStructure(movingStrand);
             state->interactor->clearCoilRegions();
	      if (coilPrint)
	         printf("Cleared coils for helix %d of strand %d\n", np, ib);
	      if(ibb < 0) {
	         cp = coilPieceFirst[np];

// Don't toggle first coil in chain, since there is no anchor to the left of it

	         if(cp > 0 && !coreCoilFirst[np]) {
	            state->interactor->toggleCoil(state->protein->pickStructure(cp));
		    if (coilPrint)
		       printf("1 Toggled coil %d for helix\n", cp);
		    }
	         }
	      else {
	         cp = coilPiece[ib][np];
	         if(!coreCoil[ib][np]) {
	            state->interactor->toggleCoil(state->protein->pickStructure(cp));
		    if (coilPrint)
		       printf("2 Toggled coil %d for helix\n", cp);
		    }
	         }
	      if(0) printf("BuildBeta toggled left coil %d\n", cp);

// If the previous alpha helix has less than 4 residues, toggle the coil before it too.

	      if (np > 0) {
		 int prevAlpha, inCore;
	         if (ibb < 0) {
	            prevAlpha = alphaPieceFirst[np-1];
		    inCore = coreCoilFirst[np-1];
		    cp = coilPieceFirst[np-1];
		    }
	         else {
	            prevAlpha = alphaPiece[ib][np-1];
		    inCore = coreCoil[ib][np-1];
		    cp = coilPiece[ib][np-1];
		    }
	         int prevCount = alphaEnd[prevAlpha] + 1 - alphaBegin[prevAlpha];
		 if(coilPrint) printf("np = %d inCore %d prevCount %d\n", np, inCore, prevCount);
	         if (!inCore && prevCount < 4) {
		    state->interactor->toggleCoil(state->protein->pickStructure(cp));
		    if (coilPrint)
		       printf("3 Toggled coil %d for helix\n", cp);
		    }
	         }
	       
// Don't toggle to right end of chain, since there are no more beta strands to hold fixed.

	      if(ib < totalStrands - 1) {
	        if(ibb < 0) {
	           for(nq = np + 1; nq < nCoilPiecesFirst; ++nq) {
		     cq = coilPieceFirst[nq];
	             if(!coreCoilFirst[nq]) {
	                state->interactor->toggleCoil(state->protein->pickStructure(cq));
		        if (coilPrint)
		           printf("4 Toggled coil %d for helix\n", cq);
		        }
	             if(0) printf("BuildBeta toggled right coil %d\n", cq);
		     }
		   }
	        else {
	           for(nq = np + 1; nq < nCoilPieces[ib]; ++nq) {
		     cq = coilPiece[ib][nq];
	             if(!coreCoil[ib][nq]) {
	                state->interactor->toggleCoil(state->protein->pickStructure(cq));
		        if (coilPrint)
		           printf("5 Toggled coil %d for helix\n", cq);
		        }
	             if(0) printf("BuildBeta toggled right coil %d\n", cq);
		     }
		   }
		}

// Compute axis of helix, using first four carboxyl carbons.

	      int count = alphaEnd[thisAlpha] + 1 - alphaBegin[thisAlpha];
	      if (count >= 4) { // count >= 4
	       ++ndo;
	       for (j = 0; j < count; ++j) {
	          residue = state->protein->pickResidue(j + alphaBegin[thisAlpha]
		      + firstResidueIndex);
		  carboxyl = residue->getCarboxyl();
		  CC[j] = carboxyl.getMajorAtom()->getPosition();
		  if(0) printf("CC[%d] = %f %f %f\n", j, CC[j][0], CC[j][1], CC[j][2]);
		  }
	       if(helixpr) printf("ndo %d alphaBegin[thisAlpha] %d alphaEnd[thisAlpha] %d\n",
	          ndo, alphaBegin[thisAlpha], alphaEnd[thisAlpha]);
	       double phi[count], psi[count];
	       state->protein->getDihedralAngles(alphaBegin[thisAlpha], count,
	          phi, psi);
	       Vector C1 = Geometry::normalize(Geometry::mid(CC[2], CC[0]) - CC[1]);
	       Vector C2 = Geometry::normalize(Geometry::mid(CC[3], CC[1]) - CC[2]);
	       Vector CE = Geometry::normalize(Geometry::mid(CC[count-1],
	          CC[count-1 - 2]) - CC[count-1 - 1]);
	       Vector axis = Geometry::normalize( Geometry::cross(C1, C2) );
	       Vector DC = CC[2] - CC[1];
	       double dt = dot(DC, axis);
	       Vector DH;
	       for(j = 0; j < 3; ++j)
	         DH[j] = DC[j] - dt*axis[j];
	       float lh = sqrt(DH[0]*DH[0] + DH[1]*DH[1] + DH[2]*DH[2]);
	       float cost = dot(C1, C2);
	       float sina = sqrt (.5-.5*cost);
	       float rad = lh/(2.*sina);
	       Point Center, firstCenter, lastCenter;
	       for(j = 0; j < 3; ++j) {
	          firstCenter[j] = CC[1][j] + rad*C1[j];
	          lastCenter[j]  = CC[count-1 - 1][j] + rad*CE[j];
		  }
	       Center = Geometry::mid(firstCenter, lastCenter);
	       if(helixpr) printf("centerdot %f cdist %f\n",
	          dot(lastCenter - firstCenter, axis) /
	          sqrt(dot(lastCenter - firstCenter, lastCenter - firstCenter)),
		  dot(Center - averageCenter, axis));
	       MD::Scalar angle1, angle2; 
	       dt = dot(axis, averagePlane);

//  Rotate helix axis to be parallel to average beta sheet plane.

	       angle1 = - PI/2. + Math::acos(dt);
	       Vector axis1 = Geometry::cross(axis, averagePlane);
	       Transformation trans1 =
	          Transformation::rotate(Transformation::Rotation::rotateAxis(axis1,angle1));
	       Transformation goalTransformation=Transformation::identity;
	       if(!make_parallel)
	          goalTransformation.leftMultiply(trans1);

//  Rotate helix axis to go in the direction between ends of anchors.

	       int e0, e1, le1, pe0;
	       if (coreBeta[iq]) {
	          e0 = betaStart[iq] + betaLength[iq] - 1;
		  le1 = betaStart[iq];
		  }
	       else {
	          e0 = bestEnd[sheet][ibq][ic];
                 le1 = bestBegin[sheet][ibq][ic];
		  }
	       if (coreBeta[ip]) {
		  pe0 = betaStart[ip] + betaLength[ip] - 1;
	          e1 = betaStart[ip];
		  }
	       else {
		  pe0 = bestEnd[sheet][ibp][ic];
	          e1 = bestBegin[sheet][ibp][ic];
		  }

	       if(helixpr) printf("move helices ib %d ip %d e0 %d e1 %d le1 %d  %d \n",
	          ib, ip, e0, e1, le1,  betaStart[ib]);

	       residue0 = state->protein->pickResidue(e0 + firstResidueIndex);
	       Point carboxyl0 = residue0->getCarboxyl().getMajorAtom()->getPosition();
	       residue1 = state->protein->pickResidue(e1 + firstResidueIndex);
	       Point carboxyl1 = residue1->getCarboxyl().getMajorAtom()->getPosition();
	       residue2 = state->protein->pickResidue(e1 + 1 + firstResidueIndex);
	       Point carboxyl2 = residue2->getCarboxyl().getMajorAtom()->getPosition();
	       residue3 = state->protein->pickResidue(e1 + 2 + firstResidueIndex);
	       Point carboxyl3 = residue3->getCarboxyl().getMajorAtom()->getPosition();

	       lresidue1 = state->protein->pickResidue(le1 + firstResidueIndex);
	       Point lcarboxyl1 = lresidue1->getCarboxyl().getMajorAtom()->getPosition();
	       lresidue2 = state->protein->pickResidue(le1 + 1 + firstResidueIndex);
	       Point lcarboxyl2 = lresidue2->getCarboxyl().getMajorAtom()->getPosition();
	       lresidue3 = state->protein->pickResidue(le1 + 2 + firstResidueIndex);
	       Point lcarboxyl3 = lresidue3->getCarboxyl().getMajorAtom()->getPosition();

	       presidue0 = state->protein->pickResidue(pe0 + firstResidueIndex);
	       Point pcarboxyl0 = presidue0->getCarboxyl().getMajorAtom()->getPosition();
	       presidue1 = state->protein->pickResidue(e1 + firstResidueIndex);
	       Point pcarboxyl1 = presidue1->getCarboxyl().getMajorAtom()->getPosition();

// Nov 12, 2007 change here, to make helix parallel as possible to a beta strand.

	       Vector db, dp, dq;
	       Point cdb, cdp, cdq;
	       if(ndo % 2 == 1) {
	          if(make_parallel) {
	             dq =  Geometry::normalize(lcarboxyl1 - carboxyl0);
	             cdq = Geometry::mid(lcarboxyl1, carboxyl0);
		     }
	          else
	             db = carboxyl1 - carboxyl0;
		  }
	       else {
	          if(make_parallel) {
	             dq =  Geometry::normalize(carboxyl0 - lcarboxyl1);
	             cdq = Geometry::mid(carboxyl0, lcarboxyl1);
		     }
	          else
	             db = carboxyl0 - carboxyl1;
		  }
	       if(make_parallel) {
	          dp =  Geometry::normalize(pcarboxyl1 - pcarboxyl0);
	          cdp = Geometry::mid(pcarboxyl1, pcarboxyl0);
		  cdb = Geometry::mid(cdp, cdq);
		  
		  if(dot(dp, dq) > 0)
		     db = dq + dp;
		  else
		     db = dq - dp;

//  Find a plane ba2 containing db as perpendicular as possible to vector averagePlane.

                 Vector ba1 = Geometry::normalize(Geometry::cross(db, averagePlane));
                 Vector ba2 = Geometry::normalize(Geometry::cross(ba1, db));

//  Rotate helix axis to be parallel to ba2 plane.

		  dt = dot(ba2, axis);
	          angle1 = - PI/2. + Math::acos(dt);
	          axis1 = Geometry::cross(axis, ba2);
	          Transformation trans1 =
	           Transformation::rotate(Transformation::Rotation::rotateAxis(axis1,angle1));
	          goalTransformation.leftMultiply(trans1);
	          if(write_helices) {
	             Vector axis1 = Geometry::normalize( Geometry::cross(ba2, DD) );
	             Vector axis2 = Geometry::normalize( Geometry::cross(ba2, axis1) );

	             if(1) {
	               fprintf(fp, "%f %f %f\n", cdb[0], cdb[1], cdb[2]);
	               fprintf(fp, "%f %f %f\n", ba2[0], ba2[1], ba2[2]);
	               fprintf(fp, "%f %f %f\n", axis1[0], axis1[1], axis1[2]);
	               fprintf(fp, "%f %f %f\n", axis2[0], axis2[1], axis2[2]);
	               fprintf(fp, "\n");
	               fprintf(fp, "%f %f %f\n", cdb[0], cdb[1], cdb[2]);
	               fprintf(fp, "%f %f %f\n", cdb[0] + ba2[0], cdb[1] + ba2[1],
		          cdb[2] + ba2[2]);
	               fprintf(fp, "\n");
	               }
	             }
		  }

	       axis = trans1.transform(axis);
	       dt = dot(db, axis)/sqrt(db[0]*db[0] + db[1]*db[1] + db[2]*db[2]);
	       angle2 = acos(dt);
	       if(dot(Geometry::cross(axis, db), averagePlane) < 0)
	          angle2 = - angle2;
	       Transformation trans2 =
	          Transformation::rotate(Transformation::Rotation::rotateAxis(
	          averagePlane, angle2));
	       goalTransformation.leftMultiply(trans2);

//  Translate helix to be spacing away from average beta sheet plane.

	       Point Center1 = goalTransformation.transform(Center);
	       DH = averageCenter - Center1;
	       Vector disp, DG;
	       DG = Geometry::mid(carboxyl0, carboxyl1) - averageCenter;
	       dt = dot(DG, averagePlane);
	       for(j = 0; j < 3; ++j) {
		  DG[j] -= dt*averagePlane[j];
	          disp[j] = DG[j] + DH[j] + ndo*spacing*averagePlane[j];
		  }
	       Transformation trans3=Transformation::translate(disp);
	       goalTransformation.leftMultiply(trans3);
	       if(offlineBuildBeta == 0 && interact ) {
                 printf("IK residual %g  ", lastIKResidual);
		  printf("before moving  helix %d in strand %d\n", np, ib);
                 printf("type r for very early return, any other character to continue \a");
                 if(getchar() == 'r') {
		         state->proteinRenderer->updateStructureFlags();
	             return;
	             }
	          }

	       if (write_helices) {
	          fprintf(fp,"%f %f %f\n",
		       averageCenter[0], averageCenter[1], averageCenter[2]);
	          fprintf(fp,"%f %f %f\n", averagePlane[0], averagePlane[1], averagePlane[2]);
	          fprintf(fp, "%f %f %f\n", axis1[0], axis1[1], axis1[2]);
	          fprintf(fp, "%f %f %f\n", axis2[0], axis2[1], axis2[2]);
	          fprintf(fp, "\n");
	          Point p1 = goalTransformation.transform(firstCenter);
		  fprintf(fp, "%f %f %f\n", p1[0], p1[1], p1[2]);
	          Point p2 = goalTransformation.transform(lastCenter);
		  fprintf(fp, "%f %f %f\n", p2[0], p2[1], p2[2]);
	          fprintf(fp, "\n");
		  }
	       applyTransformation(goalTransformation);

	       state->interactor->selectStructure(MD::Protein::StructureSelector());
              state->proteinRenderer->updateProtein();
	       if(!offlineBuildBeta) updateProteinNow();

              printf("IK residual for moving helix  %g\n", lastIKResidual);
	       if(lastIKResidual > zip_threshold) {
		  good = 0;
                 if (save_pre_move_helices) {
                    Protein::ChainAtom** atoms=state->protein->getAtomPointers();
                    for(int i=0;i<state->protein->getNumAtoms();++i)
                        atoms[i]->setPosition(pre_move_helices_coords[i]);
		  }
     }

//   The large loop below has been suppressed.

	       if(0 && lastIKResidual > zip_threshold) { // put back anchor helix

	          if(offlineBuildBeta == 0 && interact > 1) {
		     printf("before replacing anchors for helix %d in strand %d\n",
		        np, ib);
                    printf("type r to early return, any other character to continue \a");
                    if(getchar() == 'r') {
		            state->proteinRenderer->updateStructureFlags();
	                return;
	                }
	             }

//   Put back first anchor where it belongs

	          Point lnewcarboxyl1 =
		     lresidue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point lnewcarboxyl2 =
		     lresidue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point lnewcarboxyl3 =
		     lresidue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf("lnewcarboxyl1 %f %f %f\n",
		     lnewcarboxyl1[0], lnewcarboxyl1[1], lnewcarboxyl1[2]);
		  if(fixp) printf("lnewcarboxyl2 %f %f %f\n",
		     lnewcarboxyl2[0], lnewcarboxyl2[1], lnewcarboxyl2[2]);
		  if(fixp) printf("lnewcarboxyl3 %f %f %f\n",
		     lnewcarboxyl3[0], lnewcarboxyl3[1], lnewcarboxyl3[2]);

//   First rotate to align vectors between first two carboxyls.

		  axis1 = normalize(Geometry::cross(lcarboxyl2 - lcarboxyl1,
		     lnewcarboxyl2 - lnewcarboxyl1));
		  dt = dot(lcarboxyl2 - lcarboxyl1, lnewcarboxyl2 - lnewcarboxyl1) /
		     sqrt(dot(lcarboxyl2 - lcarboxyl1, lcarboxyl2 - lcarboxyl1) *
		     dot(lnewcarboxyl2 - lnewcarboxyl1, lnewcarboxyl2 - lnewcarboxyl1));
		  angle1 = acos(dt);
	          Transformation tempTransformation=Transformation::identity;
	          Transformation trans1 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis1,-angle1));
   	          tempTransformation.leftMultiply(trans1);
	          Point lncarboxyl1 = tempTransformation.transform(lnewcarboxyl1);
	          Point lncarboxyl2 = tempTransformation.transform(lnewcarboxyl2);
	          Point lncarboxyl3 = tempTransformation.transform(lnewcarboxyl3);

//   Find component of C3 - C1 perpendicular to C2 - C1.

		  axis = normalize(lcarboxyl2 - lcarboxyl1);
		  dt = dot(lcarboxyl3 - lcarboxyl1, axis);
		  double newdt = dot(lncarboxyl3 - lncarboxyl1, axis);
		  Vector CM, newCM;
		  for (j = 0; j < 3; ++j) {
		     CM[j] = lcarboxyl3[j] - lcarboxyl1[j] - dt*axis[j];
		     newCM[j] = lncarboxyl3[j] - lncarboxyl1[j] - newdt*axis[j];
		     }
		  dt = dot(newCM, CM)/sqrt(dot(CM, CM)*dot(newCM, newCM));

//   Rotate to align C3's.

		  angle2 = acos(dt);
		  if(dot(Geometry::cross(newCM, CM), axis) < 0)
		     angle2 = - angle2;
		  if(fixp) printf("angle1 %f angle2 %f\n", angle1*180./PI, angle2*180./PI);
		  Transformation trans2 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis, angle2));
 		  tempTransformation.leftMultiply(trans2);
		  Point lnwcarboxyl1 = tempTransformation.transform(lnewcarboxyl1);
		  if(fixp) printf("lnwcarboxyl1 %f %f %f\n",
		     lnwcarboxyl1[0], lnwcarboxyl1[1], lnwcarboxyl1[2]);
		  disp = lcarboxyl1 - lnwcarboxyl1;
	          Transformation trans3=Transformation::translate(disp);
	          tempTransformation.leftMultiply(trans3);
	          if(fixp) lncarboxyl1 = tempTransformation.transform(lnewcarboxyl1);
	          if(fixp) lncarboxyl2 = tempTransformation.transform(lnewcarboxyl2);
	          if(fixp) lncarboxyl3 = tempTransformation.transform(lnewcarboxyl3);
	          Point lfincarboxyl1 =
		     lresidue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point lfincarboxyl2 =
		     lresidue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point lfincarboxyl3 =
		     lresidue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf(" lcarboxyl1 %f %f %f\n",
		     lcarboxyl1[0], lcarboxyl1[1], lcarboxyl1[2]);
		  if(fixp) printf("lncarboxyl1 %f %f %f\n",
		     lncarboxyl1[0], lncarboxyl1[1], lncarboxyl1[2]);
		  if(fixp) printf("lfcarboxyl1 %f %f %f\n",
		     lfincarboxyl1[0], lfincarboxyl1[1], lfincarboxyl1[2]);
		  if(fixp) printf(" lcarboxyl2 %f %f %f\n",
		     lcarboxyl2[0], lcarboxyl2[1], lcarboxyl2[2]);
		  if(fixp) printf("lncarboxyl2 %f %f %f\n",
		     lncarboxyl2[0], lncarboxyl2[1], lncarboxyl2[2]);
		  if(fixp) printf("lfcarboxyl2 %f %f %f\n",
		     lfincarboxyl2[0], lfincarboxyl2[1], lfincarboxyl2[2]);
		  if(fixp) printf(" lcarboxyl3 %f %f %f\n",
		     lcarboxyl3[0], lcarboxyl3[1], lcarboxyl3[2]);
		  if(fixp) printf("lncarboxyl3 %f %f %f\n",
		     lncarboxyl3[0], lncarboxyl3[1], lncarboxyl3[2]);
		  if(fixp) printf("lfcarboxyl3 %f %f %f\n",
		     lfincarboxyl3[0], lfincarboxyl3[1], lfincarboxyl3[2]);

//  Form inverse of motion of first anchor

	          goalTransformation=Transformation::identity;
		  trans3 = Transformation::translate( -disp);
		  goalTransformation.leftMultiply(trans3);
		  trans2 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis, - angle2));
		  goalTransformation.leftMultiply(trans2);
	          trans1 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis1, angle1));
   	          goalTransformation.leftMultiply(trans1);
//	          goalTransformation=Transformation::identity;

//   Put back second anchor where it belongs

	          Point newcarboxyl1 =
		     residue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point newcarboxyl2 =
		     residue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point newcarboxyl3 =
		     residue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf("newcarboxyl1 %f %f %f\n",
		     newcarboxyl1[0], newcarboxyl1[1], newcarboxyl1[2]);
		  if(fixp) printf("newcarboxyl2 %f %f %f\n",
		     newcarboxyl2[0], newcarboxyl2[1], newcarboxyl2[2]);
		  if(fixp) printf("newcarboxyl3 %f %f %f\n",
		     newcarboxyl3[0], newcarboxyl3[1], newcarboxyl3[2]);

	          nextBeta = betaPiece[ib + 1];
	          movingStrand = state->protein->pickStructure(nextBeta);
	          state->interactor->selectStructure(movingStrand);
//
                 state->interactor->clearCoilRegions();
		  if (ibb < 0) {
	             cp = coilPieceFirst[np];
		     if(!coreCoilFirst[np])
	                state->interactor->toggleCoil(state->protein->pickStructure(cp));
	             for(nq = np + 1; nq < nCoilPiecesFirst; ++nq) {
		        cq = coilPieceFirst[nq];
		        if(!coreCoilFirst[nq])
	                   state->interactor->toggleCoil(state->protein->pickStructure(cq));
		        }
		     }
		  else {
	             cp = coilPiece[ib][np];
		     if(!coreCoil[ib][np])
	                state->interactor->toggleCoil(state->protein->pickStructure(cp));
	             for(nq = np + 1; nq < nCoilPieces[ib]; ++nq) {
		        cq = coilPiece[ib][nq];
		        if(!coreCoil[ib][nq])
	                   state->interactor->toggleCoil(state->protein->pickStructure(cq));
		        }
		     }
//
		  axis1 = normalize(Geometry::cross(carboxyl2 - carboxyl1, newcarboxyl2 - newcarboxyl1));
		  dt = dot(carboxyl2 - carboxyl1, newcarboxyl2 - newcarboxyl1) /
		     sqrt(dot(carboxyl2 - carboxyl1, carboxyl2 - carboxyl1) *
		     dot(newcarboxyl2 - newcarboxyl1, newcarboxyl2 - newcarboxyl1));
		  angle1 = acos(dt);
	          trans1 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis1,-angle1));
	          tempTransformation=Transformation::identity;
   	          tempTransformation.leftMultiply(trans1);
	          Point ncarboxyl1 = tempTransformation.transform(newcarboxyl1);
	          Point ncarboxyl2 = tempTransformation.transform(newcarboxyl2);
	          Point ncarboxyl3 = tempTransformation.transform(newcarboxyl3);
		  axis = normalize(carboxyl2 - carboxyl1);
		  dt = dot(carboxyl3 - carboxyl1, axis);
		  newdt = dot(ncarboxyl3 - ncarboxyl1, axis);
		  for (j = 0; j < 3; ++j) {
		     CM[j] = carboxyl3[j] - carboxyl1[j] - dt*axis[j];
		     newCM[j] = ncarboxyl3[j] - ncarboxyl1[j] - newdt*axis[j];
		     }
		  dt = dot(newCM, CM)/sqrt(dot(CM, CM)*dot(newCM, newCM));
		  angle2 = acos(dt);
		  if(dot(Geometry::cross(newCM, CM), axis) < 0)
		     angle2 = - angle2;
		  if(fixp) printf("angle1 %f angle2 %f\n", angle1*180./PI, angle2*180./PI);
		  trans2 = Transformation::rotate(
		     Transformation::Rotation::rotateAxis(axis,angle2));
 		  tempTransformation.leftMultiply(trans2);
		  Point nwcarboxyl1 = tempTransformation.transform(newcarboxyl1);
		  if(fixp) printf("nwcarboxyl1 %f %f %f\n",
		     nwcarboxyl1[0], nwcarboxyl1[1], nwcarboxyl1[2]);
		  disp = carboxyl1 - nwcarboxyl1;
	          trans3 = Transformation::translate(disp);
	          tempTransformation.leftMultiply(trans3);
	          if(fixp) ncarboxyl1 = tempTransformation.transform(newcarboxyl1);
	          if(fixp) ncarboxyl2 = tempTransformation.transform(newcarboxyl2);
	          if(fixp) ncarboxyl3 = tempTransformation.transform(newcarboxyl3);

		  goalTransformation.leftMultiply(trans1);
		  goalTransformation.leftMultiply(trans2);
		  goalTransformation.leftMultiply(trans3);
		  
	          applyTransformation(goalTransformation);

                 printf("IK residual after moving anchors %g\n", lastIKResidual);
		  if(lastIKResidual > zip_threshold)
		     good = 0;
	          state->interactor->selectStructure(MD::Protein::StructureSelector());
                 state->proteinRenderer->updateProtein();
	          if(!offlineBuildBeta) updateProteinNow();
	          Point fincarboxyl1 =
		     residue1->getCarboxyl().getMajorAtom()->getPosition();
	          Point fincarboxyl2 =
		     residue2->getCarboxyl().getMajorAtom()->getPosition();
	          Point fincarboxyl3 =
		     residue3->getCarboxyl().getMajorAtom()->getPosition();
		  if(fixp) printf(" carboxyl1 %f %f %f\n",
		     carboxyl1[0], carboxyl1[1], carboxyl1[2]);
		  if(fixp) printf("ncarboxyl1 %f %f %f\n",
		     ncarboxyl1[0], ncarboxyl1[1], ncarboxyl1[2]);
		  if(fixp) printf("fcarboxyl1 %f %f %f\n",
		     fincarboxyl1[0], fincarboxyl1[1], fincarboxyl1[2]);
		  if(fixp) printf(" carboxyl2 %f %f %f\n",
		     carboxyl2[0], carboxyl2[1], carboxyl2[2]);
		  if(fixp) printf("ncarboxyl2 %f %f %f\n",
		     ncarboxyl2[0], ncarboxyl2[1], ncarboxyl2[2]);
		  if(fixp) printf("fcarboxyl2 %f %f %f\n",
		     fincarboxyl2[0], fincarboxyl2[1], fincarboxyl2[2]);
		  if(fixp) printf(" carboxyl3 %f %f %f\n",
		     carboxyl3[0], carboxyl3[1], carboxyl3[2]);
		  if(fixp) printf("ncarboxyl3 %f %f %f\n",
		     ncarboxyl3[0], ncarboxyl3[1], ncarboxyl3[2]);
		  if(fixp) printf("fcarboxyl3 %f %f %f\n",
		     fincarboxyl3[0], fincarboxyl3[1], fincarboxyl3[2]);
		  } // put back anchor helix
	        } // count  >= 4
	       } // np 
           }  // move set of helices
         }  // ibb
	  if (write_helices) fclose(fp);
	 } // move helices
	  
	 if(offlineBuildBeta == 0 && interact) {
	    printf("after moving helices and anchors\n");
           printf("type r to return, any other character to continue \a");
           if(getchar() == 'r') {
		   state->proteinRenderer->updateStructureFlags();
	       return;
	       }
	    }
	 }                // sheets
	if (!move_helices || output_bad_helices || good) {
	 ++succeeded;
	 ++alignments;
	 ++foundThisTopology;

// output new structure.

	 if (otherprint) printf("alignments %d\n", alignments);
	 strcpy(outputfilename, protein_name);
	 strcat(outputfilename, ".");
	 sprintf(digits, "%d", succeeded);
	 if(otherprint) printf("wrote file %d ", succeeded);
	 strcat(outputfilename, digits);
	 if(move_helices && good)
	    strcat(outputfilename, ".good_helices");
	 if(do_scwrl3)
	    strcat(outputfilename, ".scwrl3");
	 strcat(outputfilename, ".topology");
	 sprintf(digits, "%d",kt);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".sheet");
	 if(otherprint) printf("kt %d lt %d mt %d\nsh ", kt, lt, mt);
	 for (k = 0; k < totalStrands; ++k) {
	       sprintf(digits, "%d", sh[k]);
	       if(otherprint) printf("%d ", sh[k]);
	       strcat(outputfilename, digits);
	       }
	 mtt = mt;
	 for(sheet = 0; sheet < core_sheets; ++sheet) {
	    if(otherprint) printf("\nsheet %d ", sheet);
           od = mtt % 4;
	    mtt /= 4;
	    if(otherprint) printf("od %d ", od);
	    strcat(outputfilename, ".up");
	    if(otherprint) printf("up ");
	    for (k = 0; k < betaCount[sheet]; ++k) {
	       sprintf(digits, "%d", up[sheet][k]);
	       if(otherprint) printf("%d ", up[sheet][k]);
	       strcat(outputfilename, digits);
	       }
	    strcat(outputfilename, ".pos");
	    if(otherprint) printf(" position ");
	    for (k = 0; k < betaCount[sheet]; ++k) {
	       sprintf(digits, "%d", positionInverse[sheet][k]+1);
	       if(otherprint) printf("%d ", positionInverse[sheet][k]+1);
	       strcat(outputfilename, digits);
	       }
           ic = multi_sheet_alignment[lt][sheet];
	    if(otherprint) printf(" ic %d s ", ic);
	    for (strand = 0; strand < betaCount[sheet]; ++strand) {
	       s = bestTotalStart[sheet][strand][ic];
	       if(otherprint) printf("%d ", s);
	       }
	    }
	 if(otherprint) printf("\n");
	 strcat(outputfilename, ".short");
	 sprintf(digits, "%d", shortcount);
	 strcat(outputfilename, digits);
	 strcat(outputfilename, ".pdb");
	 if(otherprint) printf("\n");
	 if(0) fprintf(stderr, "writing file %s\n", outputfilename);
	 printf("writing file %s\n", outputfilename);
	 fflush(NULL);
        writePdbFile(*state->protein, outputfilename, writeStructure);
	 if(printStruct) printStructure(state->protein);
	 if(do_scwrl3) {
	    strcpy(scwrl3_command, "./scwrl3 -i ");
	    strcat(scwrl3_command, outputfilename);
	    strcat(scwrl3_command, " -o ");
	    strcat(scwrl3_command, outputfilename);
	    if(has_core) {
	       strcat(scwrl3_command, " -s ");
	       strcat(scwrl3_command, sequence_file_name);
	       }
	    printf("Command given to shell:\n  %s\n", scwrl3_command);
	    fflush(stdout);
	    if (system(scwrl3_command) == -1)
	       printf("*********** system call to scwrl3 failed ***********\n");
	    }
	 fflush(stdout);
	 if(offlineBuildBeta == 0 && interact) {
	     fprintf(stderr, "input 'r' to return to interactive mode \a");
            if(getchar() == 'r') {
	         state->proteinRenderer->updateStructureFlags();
	            return;
	         }
	     }
       }
   giveUp: ;

// now lengthen strands

	 if(shpr){
	    printf("before lengthening: firstResidueIndex %d\n",
	       firstResidueIndex);
	    if(shortcount)
	       printf("shortcount %d\n");
	    }
	 if(printStruct) printStructure(state->protein);
	 if(shorten) {  // lenghtening shortened strands
         if (bond_angle_check) checkBondAngles(2);
	  if(new_lengthen == 1) { // lenghtening by copying from saveStructure

// lengthen strands by copying from saveStructure

	    for(j = 0; j < totalResidues; ++j) {
     	      switch(saveStructure[j]) {

     		case 0:
	          state->protein->changeResidueStructureType(
	             state->protein->pickResidue(j + firstResidueIndex),
	             Protein::SecondaryStructure::NONE);
		  break;
     		case 1:
	          state->protein->changeResidueStructureType(
	             state->protein->pickResidue(j + firstResidueIndex),
	             Protein::SecondaryStructure::COIL);
		  break;
     		case 2:
	          state->protein->changeResidueStructureType(
	             state->protein->pickResidue(j + firstResidueIndex),
	             Protein::SecondaryStructure::ALPHA_HELIX);
		  break;
     		case 3:
	          state->protein->changeResidueStructureType(
	             state->protein->pickResidue(j + firstResidueIndex),
	             Protein::SecondaryStructure::BETA_STRAND);
		  break;
     		default:
		  break;
	        }
	      }
	    }  // lenghtening by copying from saveStructure
	  else if (new_lengthen == 0) { // old lengthening shortened strands

// lengthen strands starting from strand ends outward

	  for(sheet = 0; sheet <= shortened_sheet; ++sheet) {
          ic = multi_sheet_alignment[lt][sheet];
	   for (strand = 0; strand < betaCount[sheet]; ++strand) {
	    i = positionInverse[sheet][strand];
	    if(coreBeta[i]) continue;
	    b0 = bestBegin[sheet][strand][ic];
	    e0 = bestEnd[sheet][strand][ic];
	    add = 0;
	    if (strand > 0)
	       if(up[sheet][strand] == up[sheet][strand - 1]) add = 1;
	    if (strand < betaCount[sheet] - 1)
	       if(up[sheet][strand] == up[sheet][strand + 1]) add = 1;
	    if(shpr) printf(
	       "i %d ic %d sheet %d strand %d begin %d end %d add %d betaStart %d betaEnd %d\n",
	       i, ic, sheet, strand, b0 - add, e0 + add, add, betaStart[i],
	       betaStart[i] + betaLength[i] - 1);
	    lengthened = 0;
	    if (i > 0 && lastCoil[i - 1] == 1)
	     for(j = b0 - add - 1; j >= betaStart[i]; --j) {
	       if(shorten > 1)
		  for (m = -2; m <= 2; ++m) {
		  if (j + m - subtract >= 0)
		     ECH = pred[j + m - subtract];
		  else
		     ECH = ' ';
	          std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
		       << "  " << ECH << "  " << saveStructure[j + m] << "  " 
		       << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
		       }
	       state->protein->changeResidueStructureType(
	          state->protein->pickResidue(j + firstResidueIndex),
	          Protein::SecondaryStructure::BETA_STRAND);
	       ++longcount;
	       if(0 && pred[j] != 'E') 
	          printf("Changed original %s residue to E\n", pred[j]);
	       lengthened = 1;
	       if(shorten > 1) printf("changed beginning residue %d to BETA_STRAND\n",
	          j + firstResidueIndex);
	       if(shorten > 1) {
		  for (m = -2; m <= 2; ++m) {
		     if (j + m - subtract >= 0)
		        ECH = pred[j + m - subtract];
		     else
		        ECH = ' ';
	             std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
		          << "  "
	                  << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
		          << "  " << ECH << "  " << saveStructure[j + m] << "  " 
		          << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
		     if(m == 0 && ((ECH == 'E' && (state->protein->pickResidue(j + firstResidueIndex))->getSecondaryStructure()->getStructureType() != 3) ||
		         (ECH == 'C' && (state->protein->pickResidue(j + firstResidueIndex))->getSecondaryStructure()->getStructureType() != 1) ) )
		            printf("******* bad lengthening result\n");
		     }
		  std::cout << "\n";
		  }
	       } 
	    if (i < betaCount[sheet] - 1 && firstCoil[i] == 1)
	     for (j = e0 + add + 1; j < betaStart[i] + betaLength[i]; ++j) {
	       if(shorten > 1)
		  for (m = -2; m <= 2; ++m) {
		  if (j + m - subtract >= 0)
		     ECH = pred[j + m - subtract];
		  else
		     ECH = ' ';
	          std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
		       << "  "
	               << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
		       << "  " << ECH << "  " << saveStructure[j + m] << "  "
		       << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
		       }
	       state->protein->changeResidueStructureType(
	          state->protein->pickResidue(j + firstResidueIndex),
	          Protein::SecondaryStructure::BETA_STRAND);
	       ++longcount;
	       if(0 && pred[j] != 'E') 
	          printf("Changed original %s residue to E\n", pred[j]);
	       lengthened = 1;
	       if(shorten > 1) printf("changed ending residue %d to BETA_STRAND\n",
	          j + firstResidueIndex);
	       if(shorten > 1) {
		  for (m = -2; m <= 2; ++m) {
		     if (j + m - subtract >= 0)
		        ECH = pred[j + m - subtract];
		     else
		        ECH = ' ';
	             std::cout << state->protein->pickResidue(j + m + firstResidueIndex)
		          << "  "
	                  << (state->protein->pickResidue(j + m + firstResidueIndex))->getSecondaryStructure()->getStructureType()
		          << "  " << ECH << "  " << saveStructure[j + m] << "  "
		          << (state->protein->pickResidue(j + m + firstResidueIndex))->getPdbResidueName() << "\n";
		     if(m == 0 && ( (ECH == 'E' && (state->protein->pickResidue(j + firstResidueIndex))->getSecondaryStructure()->getStructureType() != 3) ||
		         (ECH == 'C' && (state->protein->pickResidue(j + firstResidueIndex))->getSecondaryStructure()->getStructureType() != 1) ) )
		            printf("******* bad lengthening result\n");
		     }
		  std::cout << "\n";
		  }
	       } 
	    if(coilPrint && lengthened) printf(
	       "lengthening strand %d b0 %d e0 %d betastart %d betaEnd %d\n",
	       i, b0, e0, betaStart[i], betaStart[i] + betaLength[i] - 1);
	    state->proteinRenderer->updateStructureFlags();
	    }
	   } 
	  }   // old lengthening shortened strands 
/*
        else if (new_lengthen == 2) { // throw away structure and read it in again
	  protein = state->protein;
	  deleteProtein(protein);
	  if(otherprint) printf("rereading file %s\n", inputfilename);
	  if(validPdbForEnergy)
	     protein = parsePdbFile (inputfilename, 0);
	  else
	     parsePdbFile ( inputfilename, false, 0, 0);
	  if ( protein ) addProtein (protein, id);
	  } // throw away structure and read it in again
*/

// Restore original dihedral angles in case flattening does not do this.
	  
	 if(!flatten) {
           int numResidues, n, ib, cq, seg, firstRes;
           for(i = 0; i < totalStrands; ++i) 
              if(!coreBeta[i]) {
	          Protein::StructureSelector flatteningStrand = state->protein->pickStructure(betaPiece[i]);
	          state->interactor->selectStructure(flatteningStrand);
                 state->interactor->clearCoilRegions();
                 numResidues = state->interactor->getStructure().getNumResidues();
	          firstRes = state->interactor->getStructure().getFirstResidueIndex();
	          if(otherprint) printf("restoring %d residues in strand %d starting at %d\n",
		     numResidues, i, firstRes);
                 if(numResidues > 2 && state->interactor->isBetaStrand())
                   {
                   undoBuffer.startInteraction(state->interactor->getStructure(),state->interactor->getUpdateDirection());
                   state->interactor->setDihedralAngles(&save_phis[firstRes], &save_psis[firstRes]);
                   undoBuffer.finishInteraction();
                   state->proteinRenderer->updateProtein();
                   if(state->energyCalculator!=0)
                           state->energyCalculator->updateProtein();
                   }
                }
           state->proteinRenderer->updateStructureFlags();
	    }

	  if(shpr) printf("after lengthening\n");
	 }   // lengthening shortened strands 
	 if(longcount != shortcount) {
	     printf("longcount %d shortcount %d\n",
	        longcount, shortcount);
	     }
	 if(shpr) printf("after lengthening\n");
        if (bond_angle_check) checkBondAngles(3);
	 if(printStruct) printStructure(state->protein);
skipCase: ;
 	 if(alignments >= multi_sheet_alignments) break;
      } // odd-even cases
     }  // multi_sheet_alignments
     }  // positive probability
   if(foundThisTopology >= FIND_PER_TOPOLOGY) ++topologies;
   if(1 && topologies >= enough_topologies) {
     printf("early end to multi-sheet topology loop; found %d topologies; enough %d\n",
        topologies, enough_topologies);
     break;
     }
   bad_topology: ;
   }  // multi_sheet_topologies
   if (!list_topology_only)
    for (sheet = 0; sheet < core_sheets; ++sheet)
     printf("sheet %d succeeded %d   gave up %d  skippedCase %d %d %d %d no_zip %d zipProline %d\a\n",
     sheet, succeeded, gaveup, skippedCase1[sheet], skippedCase2[sheet],
     skippedCase3[sheet], skippedCase4[sheet], no_zip, zipProline);
 quit_distribute: ;
 }   // sheet distribution cases
 if(otherprint) printf("crossing counts ");
 for(k = 0; k < totalStrands; ++k)
    if(otherprint) printf(" %d", crosscount[k]);
 if(otherprint) printf("\n");
 fprintf(stderr, "BuildBeta is finished.\a\n");
 fflush(stdout);
 fflush(stderr);
}   // BuildBeta
}   // MD
